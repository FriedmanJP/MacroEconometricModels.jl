<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>DSGE Models · MacroEconometricModels.jl</title><meta name="title" content="DSGE Models · MacroEconometricModels.jl"/><meta property="og:title" content="DSGE Models · MacroEconometricModels.jl"/><meta property="twitter:title" content="DSGE Models · MacroEconometricModels.jl"/><meta name="description" content="Documentation for MacroEconometricModels.jl."/><meta property="og:description" content="Documentation for MacroEconometricModels.jl."/><meta property="twitter:description" content="Documentation for MacroEconometricModels.jl."/><meta property="og:url" content="https://FriedmanJP.github.io/MacroEconometricModels.jl/dsge/"/><meta property="twitter:url" content="https://FriedmanJP.github.io/MacroEconometricModels.jl/dsge/"/><link rel="canonical" href="https://FriedmanJP.github.io/MacroEconometricModels.jl/dsge/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/custom.css" rel="stylesheet" type="text/css"/><script src="../assets/theme-toggle.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MacroEconometricModels.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../data/">Data Management</a></li><li><span class="tocitem">Univariate Models</span><ul><li><a class="tocitem" href="../filters/">Time Series Filters</a></li><li><a class="tocitem" href="../arima/">ARIMA</a></li><li><a class="tocitem" href="../volatility/">Volatility Models</a></li></ul></li><li><span class="tocitem">Multivariate Models</span><ul><li><a class="tocitem" href="../manual/">VAR</a></li><li><a class="tocitem" href="../bayesian/">Bayesian VAR</a></li><li><a class="tocitem" href="../vecm/">VECM</a></li><li><a class="tocitem" href="../lp/">Local Projections</a></li><li><a class="tocitem" href="../factormodels/">Factor Models</a></li></ul></li><li><span class="tocitem">Panel Models</span><ul><li><a class="tocitem" href="../pvar/">Panel VAR</a></li></ul></li><li class="is-active"><a class="tocitem" href>DSGE Models</a><ul class="internal"><li><a class="tocitem" href="#Quick-Start"><span>Quick Start</span></a></li><li><a class="tocitem" href="#Model-Specification"><span>Model Specification</span></a></li><li><a class="tocitem" href="#Steady-State"><span>Steady State</span></a></li><li><a class="tocitem" href="#Linearization"><span>Linearization</span></a></li><li><a class="tocitem" href="#Solution-Methods"><span>Solution Methods</span></a></li><li><a class="tocitem" href="#Simulation-and-IRFs"><span>Simulation and IRFs</span></a></li><li><a class="tocitem" href="#Estimation"><span>Estimation</span></a></li><li><a class="tocitem" href="#Perfect-Foresight"><span>Perfect Foresight</span></a></li><li><a class="tocitem" href="#Occasionally-Binding-Constraints-(OccBin)"><span>Occasionally Binding Constraints (OccBin)</span></a></li><li><a class="tocitem" href="#Complete-Example"><span>Complete Example</span></a></li><li><a class="tocitem" href="#Common-Pitfalls"><span>Common Pitfalls</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../innovation_accounting/">Innovation Accounting</a></li><li><a class="tocitem" href="../nowcast/">Nowcasting</a></li><li><a class="tocitem" href="../nongaussian/">Statistical Identification</a></li><li><a class="tocitem" href="../hypothesis_tests/">Hypothesis Tests</a></li><li><a class="tocitem" href="../plotting/">Visualization</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><span class="tocitem">API Reference</span><ul><li><a class="tocitem" href="../api/">Overview</a></li><li><a class="tocitem" href="../api_types/">Types</a></li><li><a class="tocitem" href="../api_functions/">Functions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>DSGE Models</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>DSGE Models</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/FriedmanJP/MacroEconometricModels.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/main/docs/src/dsge.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="DSGE-Models"><a class="docs-heading-anchor" href="#DSGE-Models">DSGE Models</a><a id="DSGE-Models-1"></a><a class="docs-heading-anchor-permalink" href="#DSGE-Models" title="Permalink"></a></h1><p><strong>MacroEconometricModels.jl</strong> provides a complete toolkit for Dynamic Stochastic General Equilibrium (DSGE) models: specify models with the <code>@dsge</code> macro, compute steady states, linearize around the steady state, solve via Gensys (QZ decomposition) or Blanchard-Kahn, simulate and compute analytical impulse responses, estimate deep parameters via GMM, solve deterministic perfect-foresight paths, and handle occasionally binding constraints via OccBin. All results integrate with <code>plot_result()</code> for interactive visualization.</p><h2 id="Quick-Start"><a class="docs-heading-anchor" href="#Quick-Start">Quick Start</a><a id="Quick-Start-1"></a><a class="docs-heading-anchor-permalink" href="#Quick-Start" title="Permalink"></a></h2><p><strong>Recipe 1: Solve and plot IRFs</strong></p><pre><code class="language-julia hljs">using MacroEconometricModels, Random
Random.seed!(42)

# Specify a simple RBC model
spec = @dsge begin
    parameters: β = 0.99, α = 0.36, δ = 0.025, ρ = 0.9, σ = 0.01
    endogenous: Y, C, K, A
    exogenous: ε_A

    # Production
    Y[t] = A[t] * K[t-1]^α

    # Resource constraint
    C[t] + K[t] = Y[t] + (1 - δ) * K[t-1]

    # Euler equation
    1 = β * (C[t] / C[t+1]) * (α * A[t+1] * K[t]^(α - 1) + 1 - δ)

    # Technology shock
    A[t] = ρ * A[t-1] + σ * ε_A[t]

    steady_state = begin
        A_ss = 1.0
        K_ss = (α * β / (1 - β * (1 - δ)))^(1 / (1 - α))
        Y_ss = K_ss^α
        C_ss = Y_ss - δ * K_ss
        [Y_ss, C_ss, K_ss, A_ss]
    end
end

sol = solve(spec)
result = irf(sol, 40)
plot_result(result)</code></pre><p><strong>Recipe 2: Estimate with GMM</strong></p><pre><code class="language-julia hljs"># Estimate deep parameters from data
est = estimate_dsge(spec, Y_data, [:β, :α, :ρ];
                    method=:irf_matching, var_lags=4, irf_horizon=20)
report(est)</code></pre><p><strong>Recipe 3: OccBin with ZLB</strong></p><pre><code class="language-julia hljs"># Add a zero lower bound on the interest rate
constraint = parse_constraint(:(R[t] &gt;= 0), spec)
occ_sol = occbin_solve(spec, constraint; shock_path=shocks)
occ_irf = occbin_irf(spec, constraint, 1, 40)
plot_result(occ_irf)</code></pre><hr/><h2 id="Model-Specification"><a class="docs-heading-anchor" href="#Model-Specification">Model Specification</a><a id="Model-Specification-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Specification" title="Permalink"></a></h2><p>The <code>@dsge</code> macro provides a domain-specific language for specifying DSGE models. It parses the model into a <code>DSGESpec{T}</code> object containing equations, parameters, and variable declarations.</p><h3 id="Syntax"><a class="docs-heading-anchor" href="#Syntax">Syntax</a><a id="Syntax-1"></a><a class="docs-heading-anchor-permalink" href="#Syntax" title="Permalink"></a></h3><pre><code class="language-julia hljs">spec = @dsge begin
    parameters: β = 0.99, α = 0.36, δ = 0.025, ρ = 0.9, σ = 0.01
    endogenous: Y, C, K, A
    exogenous: ε_A

    # Equations (one per endogenous variable)
    Y[t] = A[t] * K[t-1]^α
    C[t] + K[t] = Y[t] + (1 - δ) * K[t-1]
    1 = β * (C[t] / C[t+1]) * (α * A[t+1] * K[t]^(α - 1) + 1 - δ)
    A[t] = ρ * A[t-1] + σ * ε_A[t]
end</code></pre><h3 id="Blocks"><a class="docs-heading-anchor" href="#Blocks">Blocks</a><a id="Blocks-1"></a><a class="docs-heading-anchor-permalink" href="#Blocks" title="Permalink"></a></h3><table><tr><th style="text-align: right">Block</th><th style="text-align: right">Syntax</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>parameters:</code></td><td style="text-align: right"><code>name = value, ...</code></td><td style="text-align: right">Calibrated parameters with default values</td></tr><tr><td style="text-align: right"><code>endogenous:</code></td><td style="text-align: right"><code>var1, var2, ...</code></td><td style="text-align: right">Endogenous variable names</td></tr><tr><td style="text-align: right"><code>exogenous:</code></td><td style="text-align: right"><code>shock1, shock2, ...</code></td><td style="text-align: right">Exogenous shock names</td></tr><tr><td style="text-align: right"><code>steady_state</code></td><td style="text-align: right"><code>= begin ... [y_ss] end</code></td><td style="text-align: right">Optional analytical steady-state function (must return vector)</td></tr><tr><td style="text-align: right"><code>varnames:</code></td><td style="text-align: right"><code>[&quot;Label 1&quot;, &quot;Label 2&quot;, ...]</code></td><td style="text-align: right">Optional display labels for variables</td></tr></table><h3 id="Time-Subscripts"><a class="docs-heading-anchor" href="#Time-Subscripts">Time Subscripts</a><a id="Time-Subscripts-1"></a><a class="docs-heading-anchor-permalink" href="#Time-Subscripts" title="Permalink"></a></h3><table><tr><th style="text-align: right">Notation</th><th style="text-align: right">Meaning</th></tr><tr><td style="text-align: right"><code>var[t]</code></td><td style="text-align: right">Current period value</td></tr><tr><td style="text-align: right"><code>var[t-1]</code></td><td style="text-align: right">One-period lag</td></tr><tr><td style="text-align: right"><code>var[t+1]</code></td><td style="text-align: right">One-period lead (forward-looking)</td></tr></table><p>Variables with <code>[t+1]</code> subscripts generate expectation errors in the Sims canonical form. The number of forward-looking equations determines the dimension of the <span>$\Pi$</span> matrix.</p><div class="admonition is-info" id="Technical-Note-bd97365efd7b6cde"><header class="admonition-header">Technical Note<a class="admonition-anchor" href="#Technical-Note-bd97365efd7b6cde" title="Permalink"></a></header><div class="admonition-body"><p>Equations are written as <code>LHS = RHS</code> where both sides can contain endogenous variables at different time subscripts. The <code>@dsge</code> macro rearranges each equation into residual form <span>$f(y_t, y_{t-1}, y_{t+1}, \varepsilon_t, \theta) = 0$</span> via <code>LHS - RHS</code>. The number of equations must equal the number of endogenous variables.</p></div></div><h3 id="Return-Value"><a class="docs-heading-anchor" href="#Return-Value">Return Value</a><a id="Return-Value-1"></a><a class="docs-heading-anchor-permalink" href="#Return-Value" title="Permalink"></a></h3><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Type</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>endog</code></td><td style="text-align: right"><code>Vector{Symbol}</code></td><td style="text-align: right">Endogenous variable names</td></tr><tr><td style="text-align: right"><code>exog</code></td><td style="text-align: right"><code>Vector{Symbol}</code></td><td style="text-align: right">Exogenous shock names</td></tr><tr><td style="text-align: right"><code>params</code></td><td style="text-align: right"><code>Vector{Symbol}</code></td><td style="text-align: right">Parameter names</td></tr><tr><td style="text-align: right"><code>param_values</code></td><td style="text-align: right"><code>Dict{Symbol,T}</code></td><td style="text-align: right">Calibrated values</td></tr><tr><td style="text-align: right"><code>equations</code></td><td style="text-align: right"><code>Vector{Expr}</code></td><td style="text-align: right">Raw equation expressions</td></tr><tr><td style="text-align: right"><code>n_endog</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Number of endogenous variables</td></tr><tr><td style="text-align: right"><code>n_exog</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Number of exogenous shocks</td></tr><tr><td style="text-align: right"><code>n_expect</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Number of expectation errors</td></tr><tr><td style="text-align: right"><code>forward_indices</code></td><td style="text-align: right"><code>Vector{Int}</code></td><td style="text-align: right">Indices of forward-looking equations</td></tr><tr><td style="text-align: right"><code>steady_state</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">Steady-state values</td></tr><tr><td style="text-align: right"><code>varnames</code></td><td style="text-align: right"><code>Vector{String}</code></td><td style="text-align: right">Display names</td></tr></table><hr/><h2 id="Steady-State"><a class="docs-heading-anchor" href="#Steady-State">Steady State</a><a id="Steady-State-1"></a><a class="docs-heading-anchor-permalink" href="#Steady-State" title="Permalink"></a></h2><p>The steady state <span>$\bar{y}$</span> satisfies the system in the absence of shocks:</p><p class="math-container">\[f(\bar{y}, \bar{y}, \bar{y}, 0, \theta) = 0\]</p><h3 id="Numerical-Computation"><a class="docs-heading-anchor" href="#Numerical-Computation">Numerical Computation</a><a id="Numerical-Computation-1"></a><a class="docs-heading-anchor-permalink" href="#Numerical-Computation" title="Permalink"></a></h3><pre><code class="language-julia hljs">spec = compute_steady_state(spec)
println(&quot;Steady state: &quot;, spec.steady_state)</code></pre><p><code>compute_steady_state</code> uses a two-phase optimizer: Nelder-Mead for robustness, then L-BFGS for refinement. It minimizes the sum of squared residuals <span>$\sum_i f_i(\bar{y})^2$</span>.</p><table><tr><th style="text-align: right">Keyword</th><th style="text-align: right">Type</th><th style="text-align: right">Default</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>initial_guess</code></td><td style="text-align: right"><code>Vector</code></td><td style="text-align: right"><code>nothing</code></td><td style="text-align: right">Starting point (default: ones)</td></tr><tr><td style="text-align: right"><code>method</code></td><td style="text-align: right"><code>Symbol</code></td><td style="text-align: right"><code>:auto</code></td><td style="text-align: right"><code>:auto</code> (NelderMead → LBFGS) or <code>:analytical</code></td></tr></table><h3 id="Analytical-Steady-State"><a class="docs-heading-anchor" href="#Analytical-Steady-State">Analytical Steady State</a><a id="Analytical-Steady-State-1"></a><a class="docs-heading-anchor-permalink" href="#Analytical-Steady-State" title="Permalink"></a></h3><p>For models where the steady state has a closed-form solution, specify it in a <code>steady_state = begin ... end</code> block. The block must return a vector matching the endogenous variable ordering:</p><pre><code class="language-julia hljs">spec = @dsge begin
    parameters: β = 0.99, α = 0.36, δ = 0.025, ρ = 0.9, σ = 0.01
    endogenous: Y, C, K, A
    exogenous: ε_A

    Y[t] = A[t] * K[t-1]^α
    C[t] + K[t] = Y[t] + (1 - δ) * K[t-1]
    1 = β * (C[t] / C[t+1]) * (α * A[t+1] * K[t]^(α - 1) + 1 - δ)
    A[t] = ρ * A[t-1] + σ * ε_A[t]

    steady_state = begin
        A_ss = 1.0
        K_ss = (α * β / (1 - β * (1 - δ)))^(1 / (1 - α))
        Y_ss = K_ss^α
        C_ss = Y_ss - δ * K_ss
        [Y_ss, C_ss, K_ss, A_ss]
    end
end</code></pre><p>When the <code>steady_state</code> block is provided, <code>compute_steady_state</code> (or <code>solve</code>) uses it directly and validates the result against the equations.</p><hr/><h2 id="Linearization"><a class="docs-heading-anchor" href="#Linearization">Linearization</a><a id="Linearization-1"></a><a class="docs-heading-anchor-permalink" href="#Linearization" title="Permalink"></a></h2><p><code>linearize</code> computes a first-order approximation around the steady state using numerical Jacobians (central differences). It produces the Sims (2002) canonical form:</p><p class="math-container">\[\Gamma_0 \, y_t = \Gamma_1 \, y_{t-1} + C + \Psi \, \varepsilon_t + \Pi \, \eta_t\]</p><p>where <span>$y_t$</span> is the vector of endogenous variables (in deviations from steady state), <span>$\varepsilon_t$</span> is the vector of exogenous shocks, and <span>$\eta_t$</span> is the vector of expectation errors.</p><pre><code class="language-julia hljs">ld = linearize(spec)</code></pre><div class="admonition is-info" id="Technical-Note-1f2f408ab552a0b6"><header class="admonition-header">Technical Note<a class="admonition-anchor" href="#Technical-Note-1f2f408ab552a0b6" title="Permalink"></a></header><div class="admonition-body"><p>The matrices are computed via central differences with step size <span>$h = \max(10^{-7}, 10^{-7} |y_j|)$</span>. No analytical derivatives are required. <span>$\Gamma_0$</span> contains coefficients on <span>$y_t$</span>, <span>$\Gamma_1$</span> on <span>$y_{t-1}$</span>, <span>$\Psi$</span> on shocks, and <span>$\Pi$</span> selects the forward-looking equations for expectation errors.</p></div></div><h3 id="Return-Value-2"><a class="docs-heading-anchor" href="#Return-Value-2">Return Value</a><a class="docs-heading-anchor-permalink" href="#Return-Value-2" title="Permalink"></a></h3><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Type</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>Gamma0</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right"><span>$n \times n$</span> coefficient on <span>$y_t$</span></td></tr><tr><td style="text-align: right"><code>Gamma1</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right"><span>$n \times n$</span> coefficient on <span>$y_{t-1}$</span></td></tr><tr><td style="text-align: right"><code>C</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right"><span>$n \times 1$</span> constants</td></tr><tr><td style="text-align: right"><code>Psi</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right"><span>$n \times n_{shocks}$</span> shock loading</td></tr><tr><td style="text-align: right"><code>Pi</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right"><span>$n \times n_{expect}$</span> expectation error selection</td></tr><tr><td style="text-align: right"><code>spec</code></td><td style="text-align: right"><code>DSGESpec{T}</code></td><td style="text-align: right">Back-reference to specification</td></tr></table><hr/><h2 id="Solution-Methods"><a class="docs-heading-anchor" href="#Solution-Methods">Solution Methods</a><a id="Solution-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Solution-Methods" title="Permalink"></a></h2><p><code>solve</code> is the unified entry point for solving DSGE models. It dispatches to the appropriate solver based on the <code>method</code> keyword:</p><pre><code class="language-julia hljs">sol = solve(spec; method=:gensys)</code></pre><table><tr><th style="text-align: right">Method</th><th style="text-align: right">Algorithm</th><th style="text-align: right">Reference</th></tr><tr><td style="text-align: right"><code>:gensys</code> (default)</td><td style="text-align: right">QZ decomposition</td><td style="text-align: right">Sims (2002)</td></tr><tr><td style="text-align: right"><code>:blanchard_kahn</code></td><td style="text-align: right">Eigenvalue counting</td><td style="text-align: right">Blanchard &amp; Kahn (1980)</td></tr><tr><td style="text-align: right"><code>:perfect_foresight</code></td><td style="text-align: right">Deterministic Newton solver</td><td style="text-align: right">–-</td></tr></table><p><code>solve</code> automatically calls <code>compute_steady_state</code> and <code>linearize</code> if they have not been called already.</p><h3 id="Choosing-a-Solver"><a class="docs-heading-anchor" href="#Choosing-a-Solver">Choosing a Solver</a><a id="Choosing-a-Solver-1"></a><a class="docs-heading-anchor-permalink" href="#Choosing-a-Solver" title="Permalink"></a></h3><table><tr><th style="text-align: right"></th><th style="text-align: right">Gensys (QZ)</th><th style="text-align: right">Blanchard-Kahn</th></tr><tr><td style="text-align: right"><strong>Algorithm</strong></td><td style="text-align: right">QZ (generalized Schur) decomposition</td><td style="text-align: right">Eigenvalue decomposition of <span>$\Gamma_0^{-1}\Gamma_1$</span></td></tr><tr><td style="text-align: right"><strong>Determinacy</strong></td><td style="text-align: right">Reports <code>eu = [existence, uniqueness]</code></td><td style="text-align: right">Requires <span>$n_{unstable} = n_{forward}$</span> exactly</td></tr><tr><td style="text-align: right"><strong>Sunspot solutions</strong></td><td style="text-align: right">Can construct sunspot representations (<code>eu[2] = 0</code>)</td><td style="text-align: right">Fails if condition violated</td></tr><tr><td style="text-align: right"><strong>Singularity</strong></td><td style="text-align: right">Handles singular <span>$\Gamma_0$</span> via QZ</td><td style="text-align: right">Requires <span>$\Gamma_0$</span> invertible</td></tr><tr><td style="text-align: right"><strong>Speed</strong></td><td style="text-align: right">Slightly slower (QZ is O(n³) with larger constant)</td><td style="text-align: right">Faster for small models</td></tr><tr><td style="text-align: right"><strong>Recommended</strong></td><td style="text-align: right">General-purpose default</td><td style="text-align: right">Simple models with invertible <span>$\Gamma_0$</span></td></tr></table><p>Use <code>:gensys</code> (the default) unless you have a specific reason to prefer Blanchard-Kahn. The Gensys solver is more robust and provides richer diagnostic output.</p><h3 id="Gensys"><a class="docs-heading-anchor" href="#Gensys">Gensys</a><a id="Gensys-1"></a><a class="docs-heading-anchor-permalink" href="#Gensys" title="Permalink"></a></h3><p>The Gensys algorithm (Sims 2002) solves the linearized system via QZ (generalized Schur) decomposition. It separates stable and unstable eigenvalues to construct the state-space solution:</p><p class="math-container">\[y_t = G_1 \, y_{t-1} + C_{sol} + \text{impact} \cdot \varepsilon_t\]</p><p>where <span>$G_1$</span> is the <span>$n \times n$</span> state transition matrix and <span>$\text{impact}$</span> is the <span>$n \times n_{shocks}$</span> impact matrix.</p><pre><code class="language-julia hljs">sol = solve(spec; method=:gensys)
println(&quot;Existence: &quot;, sol.eu[1] == 1)    # 1 = exists
println(&quot;Uniqueness: &quot;, sol.eu[2] == 1)   # 1 = unique</code></pre><div class="admonition is-info" id="Technical-Note-d72f1c8d7249b09e"><header class="admonition-header">Technical Note<a class="admonition-anchor" href="#Technical-Note-d72f1c8d7249b09e" title="Permalink"></a></header><div class="admonition-body"><p>The <code>div</code> keyword (default <span>$1.0 + 10^{-8}$</span>) sets the dividing line between stable and unstable eigenvalues. Eigenvalues with modulus below <code>div</code> are classified as stable. The <code>eu</code> vector reports <code>[existence, uniqueness]</code> where 1 = satisfied, 0 = violated.</p></div></div><h3 id="Blanchard-Kahn"><a class="docs-heading-anchor" href="#Blanchard-Kahn">Blanchard-Kahn</a><a id="Blanchard-Kahn-1"></a><a class="docs-heading-anchor-permalink" href="#Blanchard-Kahn" title="Permalink"></a></h3><p>The Blanchard-Kahn (1980) method partitions the system into predetermined and forward-looking variables. The determinacy condition requires the number of unstable eigenvalues to equal the number of forward-looking variables:</p><pre><code class="language-julia hljs">sol = solve(spec; method=:blanchard_kahn)</code></pre><div class="admonition is-warning" id="Warning-7dc9df32f8eff8d2"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-7dc9df32f8eff8d2" title="Permalink"></a></header><div class="admonition-body"><p>The Blanchard-Kahn method requires exactly <code>n_unstable == n_forward_looking</code>. If this condition fails, the model is either indeterminate (too few unstable roots) or has no stable solution (too many).</p></div></div><h3 id="Diagnosing-Indeterminacy"><a class="docs-heading-anchor" href="#Diagnosing-Indeterminacy">Diagnosing Indeterminacy</a><a id="Diagnosing-Indeterminacy-1"></a><a class="docs-heading-anchor-permalink" href="#Diagnosing-Indeterminacy" title="Permalink"></a></h3><p>When a model fails the Blanchard-Kahn condition or Gensys reports <code>eu[2] = 0</code>, inspect the eigenvalues:</p><pre><code class="language-julia hljs">sol = solve(spec; method=:gensys)
println(&quot;Eigenvalues: &quot;, abs.(sol.eigenvalues))
println(&quot;EU: &quot;, sol.eu)

# Count stable vs unstable roots
n_stable = count(abs.(sol.eigenvalues) .&lt; 1.0)
n_unstable = count(abs.(sol.eigenvalues) .&gt;= 1.0)
n_forward = spec.n_expect

println(&quot;Stable: $n_stable, Unstable: $n_unstable, Forward-looking: $n_forward&quot;)

# Determinacy requires n_unstable == n_forward
if n_unstable &lt; n_forward
    println(&quot;INDETERMINATE: too few unstable roots — sunspot equilibria exist&quot;)
elseif n_unstable &gt; n_forward
    println(&quot;NO STABLE SOLUTION: too many unstable roots&quot;)
else
    println(&quot;DETERMINATE: unique stable solution&quot;)
end</code></pre><div class="admonition is-warning" id="Common-cause-of-indeterminacy-cab99add7719ee9a"><header class="admonition-header">Common cause of indeterminacy<a class="admonition-anchor" href="#Common-cause-of-indeterminacy-cab99add7719ee9a" title="Permalink"></a></header><div class="admonition-body"><p>The Taylor principle requires <span>$\phi_\pi &gt; 1$</span> in the Taylor rule. With <span>$\phi_\pi &lt; 1$</span>, the NK model is typically indeterminate (too few unstable roots).</p></div></div><h3 id="Determinacy-and-Stability"><a class="docs-heading-anchor" href="#Determinacy-and-Stability">Determinacy and Stability</a><a id="Determinacy-and-Stability-1"></a><a class="docs-heading-anchor-permalink" href="#Determinacy-and-Stability" title="Permalink"></a></h3><pre><code class="language-julia hljs">is_determined(sol)   # true if eu == [1, 1]
is_stable(sol)       # true if max|eigenvalue(G1)| &lt; 1</code></pre><h3 id="Return-Value-3"><a class="docs-heading-anchor" href="#Return-Value-3">Return Value</a><a class="docs-heading-anchor-permalink" href="#Return-Value-3" title="Permalink"></a></h3><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Type</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>G1</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right"><span>$n \times n$</span> state transition</td></tr><tr><td style="text-align: right"><code>impact</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right"><span>$n \times n_{shocks}$</span> impact matrix</td></tr><tr><td style="text-align: right"><code>C_sol</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right"><span>$n \times 1$</span> constants</td></tr><tr><td style="text-align: right"><code>eu</code></td><td style="text-align: right"><code>Vector{Int}</code></td><td style="text-align: right"><code>[existence, uniqueness]</code> (1=yes, 0=no)</td></tr><tr><td style="text-align: right"><code>method</code></td><td style="text-align: right"><code>Symbol</code></td><td style="text-align: right"><code>:gensys</code> or <code>:blanchard_kahn</code></td></tr><tr><td style="text-align: right"><code>eigenvalues</code></td><td style="text-align: right"><code>Vector{ComplexF64}</code></td><td style="text-align: right">Generalized eigenvalues</td></tr><tr><td style="text-align: right"><code>spec</code></td><td style="text-align: right"><code>DSGESpec{T}</code></td><td style="text-align: right">Model specification</td></tr><tr><td style="text-align: right"><code>linear</code></td><td style="text-align: right"><code>LinearDSGE{T}</code></td><td style="text-align: right">Linearized form</td></tr></table><hr/><h2 id="Simulation-and-IRFs"><a class="docs-heading-anchor" href="#Simulation-and-IRFs">Simulation and IRFs</a><a id="Simulation-and-IRFs-1"></a><a class="docs-heading-anchor-permalink" href="#Simulation-and-IRFs" title="Permalink"></a></h2><h3 id="Stochastic-Simulation"><a class="docs-heading-anchor" href="#Stochastic-Simulation">Stochastic Simulation</a><a id="Stochastic-Simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Stochastic-Simulation" title="Permalink"></a></h3><p><code>simulate</code> generates sample paths from the solved model:</p><p class="math-container">\[y_t = G_1 \, y_{t-1} + \text{impact} \cdot \varepsilon_t + C_{sol}\]</p><pre><code class="language-julia hljs">Y_sim = simulate(sol, 200; rng=Random.MersenneTwister(42))
# Returns 200 × n_endog matrix in levels (steady state + deviations)</code></pre><table><tr><th style="text-align: right">Keyword</th><th style="text-align: right">Type</th><th style="text-align: right">Default</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>shock_draws</code></td><td style="text-align: right"><code>Matrix</code></td><td style="text-align: right"><code>nothing</code></td><td style="text-align: right">Pre-drawn shocks (<span>$T \times n_{shocks}$</span>)</td></tr><tr><td style="text-align: right"><code>rng</code></td><td style="text-align: right"><code>AbstractRNG</code></td><td style="text-align: right"><code>default_rng()</code></td><td style="text-align: right">Random number generator</td></tr></table><h3 id="Impulse-Response-Functions"><a class="docs-heading-anchor" href="#Impulse-Response-Functions">Impulse Response Functions</a><a id="Impulse-Response-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Impulse-Response-Functions" title="Permalink"></a></h3><p><code>irf</code> computes analytical impulse responses:</p><p class="math-container">\[\Phi_h = G_1^{h-1} \cdot \text{impact}\]</p><p>where <span>$\Phi_h$</span> is the response at horizon <span>$h$</span> to a one-standard-deviation shock.</p><pre><code class="language-julia hljs">result = irf(sol, 40)
plot_result(result)</code></pre><p>Returns an <code>ImpulseResponse{T}</code> object compatible with the standard <code>plot_result()</code> method for multi-panel IRF plots.</p><h3 id="Forecast-Error-Variance-Decomposition"><a class="docs-heading-anchor" href="#Forecast-Error-Variance-Decomposition">Forecast Error Variance Decomposition</a><a id="Forecast-Error-Variance-Decomposition-1"></a><a class="docs-heading-anchor-permalink" href="#Forecast-Error-Variance-Decomposition" title="Permalink"></a></h3><p><code>fevd</code> computes the share of forecast variance attributable to each shock at each horizon:</p><p class="math-container">\[\text{FEVD}_{ij}(h) = \frac{\sum_{s=0}^{h-1} (\Phi_s e_j)&#39; (\Phi_s e_j)}{\sum_{s=0}^{h-1} \text{tr}(\Phi_s \Phi_s&#39;)}\]</p><pre><code class="language-julia hljs">result = fevd(sol, 40)
plot_result(result)</code></pre><p>Returns a <code>FEVD{T}</code> object compatible with <code>plot_result()</code>.</p><h3 id="Unconditional-Variance"><a class="docs-heading-anchor" href="#Unconditional-Variance">Unconditional Variance</a><a id="Unconditional-Variance-1"></a><a class="docs-heading-anchor-permalink" href="#Unconditional-Variance" title="Permalink"></a></h3><p><code>solve_lyapunov</code> solves the discrete Lyapunov equation for the unconditional covariance:</p><p class="math-container">\[\Sigma = G_1 \, \Sigma \, G_1&#39; + \text{impact} \cdot \text{impact}&#39;\]</p><pre><code class="language-julia hljs">Sigma = solve_lyapunov(sol.G1, sol.impact)</code></pre><div class="admonition is-info" id="Technical-Note-8ea138426b500b24"><header class="admonition-header">Technical Note<a class="admonition-anchor" href="#Technical-Note-8ea138426b500b24" title="Permalink"></a></header><div class="admonition-body"><p>Uses Kronecker vectorization: <span>$\text{vec}(\Sigma) = (I - G_1 \otimes G_1)^{-1} \text{vec}(\text{impact} \cdot \text{impact}&#39;)$</span>. Throws <code>ArgumentError</code> if <span>$G_1$</span> is unstable.</p></div></div><h3 id="Analytical-Moments"><a class="docs-heading-anchor" href="#Analytical-Moments">Analytical Moments</a><a id="Analytical-Moments-1"></a><a class="docs-heading-anchor-permalink" href="#Analytical-Moments" title="Permalink"></a></h3><p><code>analytical_moments</code> computes the theoretical moment vector from the Lyapunov solution:</p><pre><code class="language-julia hljs">m = analytical_moments(sol; lags=2)</code></pre><p>Returns a concatenated vector: upper-triangle of the variance-covariance matrix (<span>$k(k+1)/2$</span> elements) followed by diagonal autocovariances at each lag (<span>$k$</span> elements per lag). These moments are used internally by the <code>:analytical_gmm</code> estimation method.</p><hr/><h2 id="Estimation"><a class="docs-heading-anchor" href="#Estimation">Estimation</a><a id="Estimation-1"></a><a class="docs-heading-anchor-permalink" href="#Estimation" title="Permalink"></a></h2><p><code>estimate_dsge</code> estimates DSGE deep parameters via Generalized Method of Moments:</p><pre><code class="language-julia hljs">est = estimate_dsge(spec, Y_data, [:β, :ρ, :σ]; method=:irf_matching)
report(est)</code></pre><h3 id="Methods"><a class="docs-heading-anchor" href="#Methods">Methods</a><a id="Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Methods" title="Permalink"></a></h3><table><tr><th style="text-align: right">Method</th><th style="text-align: right">Description</th><th style="text-align: right">Reference</th></tr><tr><td style="text-align: right"><code>:irf_matching</code></td><td style="text-align: right">Match model IRFs to empirical VAR IRFs</td><td style="text-align: right">Christiano, Eichenbaum &amp; Evans (2005)</td></tr><tr><td style="text-align: right"><code>:euler_gmm</code></td><td style="text-align: right">Euler equation moment conditions with lagged instruments</td><td style="text-align: right">Hansen &amp; Singleton (1982)</td></tr><tr><td style="text-align: right"><code>:smm</code></td><td style="text-align: right">Simulated Method of Moments</td><td style="text-align: right">–-</td></tr><tr><td style="text-align: right"><code>:analytical_gmm</code></td><td style="text-align: right">Analytical moments via Lyapunov equation</td><td style="text-align: right">–-</td></tr></table><h3 id="IRF-Matching"><a class="docs-heading-anchor" href="#IRF-Matching">IRF Matching</a><a id="IRF-Matching-1"></a><a class="docs-heading-anchor-permalink" href="#IRF-Matching" title="Permalink"></a></h3><p>Estimates parameters by minimizing the distance between model-implied and data-implied impulse responses:</p><p class="math-container">\[\hat{\theta} = \arg\min_\theta \, [\Phi^{data}(H) - \Phi^{model}(\theta, H)]&#39; \, W \, [\Phi^{data}(H) - \Phi^{model}(\theta, H)]\]</p><p>where <span>$\Phi^{data}$</span> is estimated from a VAR on the data and <span>$W$</span> is the GMM weighting matrix.</p><p><strong>When to use:</strong> When you have a VAR-identified structural shock and want to match the DSGE model&#39;s propagation mechanism to the data. This is the most common method for medium-scale DSGE models.</p><pre><code class="language-julia hljs">est = estimate_dsge(spec, Y_data, [:β, :α, :ρ];
                    method=:irf_matching,
                    var_lags=4,
                    irf_horizon=20,
                    weighting=:two_step)</code></pre><pre><code class="language-julia hljs"># Worked example: estimate NK parameters from simulated data
using MacroEconometricModels, Random
Random.seed!(42)

spec = @dsge begin
    parameters: β = 0.99, σ_c = 1.0, κ = 0.3, φ_π = 1.5, φ_y = 0.5,
                ρ_d = 0.8, σ_d = 0.01
    endogenous: y, π, R, d
    exogenous: ε_d

    y[t] = y[t+1] - (1 / σ_c) * (R[t] - π[t+1]) + d[t]
    π[t] = β * π[t+1] + κ * y[t]
    R[t] = φ_π * π[t] + φ_y * y[t]
    d[t] = ρ_d * d[t-1] + σ_d * ε_d[t]
end

sol = solve(spec)
Y_sim = simulate(sol, 500; rng=Random.MersenneTwister(42))

est = estimate_dsge(spec, Y_sim, [:κ, :ρ_d];
                    method=:irf_matching, var_lags=4, irf_horizon=20,
                    weighting=:two_step)
report(est)</code></pre><h3 id="Euler-Equation-GMM"><a class="docs-heading-anchor" href="#Euler-Equation-GMM">Euler Equation GMM</a><a id="Euler-Equation-GMM-1"></a><a class="docs-heading-anchor-permalink" href="#Euler-Equation-GMM" title="Permalink"></a></h3><p>Uses Euler equation residuals as moment conditions with lagged variables as instruments:</p><p><strong>When to use:</strong> When the model has a well-defined Euler equation and you want to avoid the computational cost of repeatedly solving the model during optimization. Works directly with first-order conditions.</p><pre><code class="language-julia hljs">est = estimate_dsge(spec, Y_data, [:β, :ρ];
                    method=:euler_gmm,
                    n_lags_instruments=4)</code></pre><h3 id="Simulated-Method-of-Moments-(SMM)"><a class="docs-heading-anchor" href="#Simulated-Method-of-Moments-(SMM)">Simulated Method of Moments (SMM)</a><a id="Simulated-Method-of-Moments-(SMM)-1"></a><a class="docs-heading-anchor-permalink" href="#Simulated-Method-of-Moments-(SMM)" title="Permalink"></a></h3><p>Matches simulated moments to data moments:</p><pre><code class="language-julia hljs">est = estimate_dsge(spec, Y_data, [:β, :ρ, :σ];
                    method=:smm,
                    sim_ratio=5,
                    burn=100)</code></pre><div class="admonition is-info" id="Simulation-noise-d3e0b483566f1c82"><header class="admonition-header">Simulation noise<a class="admonition-anchor" href="#Simulation-noise-d3e0b483566f1c82" title="Permalink"></a></header><div class="admonition-body"><p>SMM estimates are noisier than analytical GMM due to simulation error. Increase <code>sim_ratio</code> to reduce this noise. The asymptotic variance correction factor is <span>$(1 + 1/\text{sim\_ratio})$</span>.</p></div></div><h3 id="Analytical-GMM"><a class="docs-heading-anchor" href="#Analytical-GMM">Analytical GMM</a><a id="Analytical-GMM-1"></a><a class="docs-heading-anchor-permalink" href="#Analytical-GMM" title="Permalink"></a></h3><p>Uses Lyapunov-equation-based moments (no simulation noise):</p><p><strong>When to use:</strong> This is the most efficient method when the model is linear and you want to match second-moment properties. No simulation noise.</p><pre><code class="language-julia hljs">est = estimate_dsge(spec, Y_data, [:β, :ρ];
                    method=:analytical_gmm,
                    lags=2)</code></pre><h3 id="Hansen-J-test"><a class="docs-heading-anchor" href="#Hansen-J-test">Hansen J-test</a><a id="Hansen-J-test-1"></a><a class="docs-heading-anchor-permalink" href="#Hansen-J-test" title="Permalink"></a></h3><p>All methods report the overidentification test:</p><pre><code class="language-julia hljs">println(&quot;J-statistic: &quot;, est.J_stat)
println(&quot;p-value: &quot;, est.J_pvalue)</code></pre><p>A large p-value indicates the model&#39;s moment conditions are not rejected by the data.</p><h3 id="Keywords"><a class="docs-heading-anchor" href="#Keywords">Keywords</a><a id="Keywords-1"></a><a class="docs-heading-anchor-permalink" href="#Keywords" title="Permalink"></a></h3><table><tr><th style="text-align: right">Keyword</th><th style="text-align: right">Type</th><th style="text-align: right">Default</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>method</code></td><td style="text-align: right"><code>Symbol</code></td><td style="text-align: right"><code>:irf_matching</code></td><td style="text-align: right">Estimation method</td></tr><tr><td style="text-align: right"><code>target_irfs</code></td><td style="text-align: right"><code>ImpulseResponse</code></td><td style="text-align: right"><code>nothing</code></td><td style="text-align: right">Pre-computed empirical IRFs</td></tr><tr><td style="text-align: right"><code>var_lags</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right"><code>4</code></td><td style="text-align: right">VAR lag order for empirical IRFs</td></tr><tr><td style="text-align: right"><code>irf_horizon</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right"><code>20</code></td><td style="text-align: right">IRF horizon for matching</td></tr><tr><td style="text-align: right"><code>weighting</code></td><td style="text-align: right"><code>Symbol</code></td><td style="text-align: right"><code>:two_step</code></td><td style="text-align: right">GMM weighting matrix</td></tr><tr><td style="text-align: right"><code>n_lags_instruments</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right"><code>4</code></td><td style="text-align: right">Instrument lags for Euler GMM</td></tr><tr><td style="text-align: right"><code>sim_ratio</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right"><code>5</code></td><td style="text-align: right">Simulation ratio for SMM</td></tr><tr><td style="text-align: right"><code>burn</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right"><code>100</code></td><td style="text-align: right">Burn-in periods for SMM</td></tr><tr><td style="text-align: right"><code>moments_fn</code></td><td style="text-align: right"><code>Function</code></td><td style="text-align: right"><code>autocovariance_moments</code></td><td style="text-align: right">Moment function for SMM</td></tr><tr><td style="text-align: right"><code>bounds</code></td><td style="text-align: right"><code>ParameterTransform</code></td><td style="text-align: right"><code>nothing</code></td><td style="text-align: right">Parameter bounds</td></tr><tr><td style="text-align: right"><code>lags</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right"><code>1</code></td><td style="text-align: right">Autocovariance lags for analytical GMM</td></tr></table><h3 id="Return-Value-4"><a class="docs-heading-anchor" href="#Return-Value-4">Return Value</a><a class="docs-heading-anchor-permalink" href="#Return-Value-4" title="Permalink"></a></h3><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Type</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>theta</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">Estimated deep parameters</td></tr><tr><td style="text-align: right"><code>vcov</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right">Asymptotic covariance matrix</td></tr><tr><td style="text-align: right"><code>param_names</code></td><td style="text-align: right"><code>Vector{Symbol}</code></td><td style="text-align: right">Parameter names</td></tr><tr><td style="text-align: right"><code>method</code></td><td style="text-align: right"><code>Symbol</code></td><td style="text-align: right">Estimation method used</td></tr><tr><td style="text-align: right"><code>J_stat</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">Hansen J-test statistic</td></tr><tr><td style="text-align: right"><code>J_pvalue</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">J-test p-value</td></tr><tr><td style="text-align: right"><code>solution</code></td><td style="text-align: right"><code>DSGESolution{T}</code></td><td style="text-align: right">Solution at estimated parameters</td></tr><tr><td style="text-align: right"><code>converged</code></td><td style="text-align: right"><code>Bool</code></td><td style="text-align: right">Optimization convergence</td></tr><tr><td style="text-align: right"><code>spec</code></td><td style="text-align: right"><code>DSGESpec{T}</code></td><td style="text-align: right">Model specification</td></tr></table><p>Standard StatsAPI interface: <code>coef(est)</code>, <code>vcov(est)</code>, <code>stderror(est)</code>, <code>dof(est)</code>.</p><hr/><h2 id="Perfect-Foresight"><a class="docs-heading-anchor" href="#Perfect-Foresight">Perfect Foresight</a><a id="Perfect-Foresight-1"></a><a class="docs-heading-anchor-permalink" href="#Perfect-Foresight" title="Permalink"></a></h2><p><code>perfect_foresight</code> solves for the deterministic transition path given a known sequence of future shocks. The agents know the exact realization of shocks in advance (no uncertainty):</p><pre><code class="language-julia hljs"># Solve with perfect foresight
sol = solve(spec; method=:perfect_foresight,
            T_periods=100, shock_path=shock_matrix)</code></pre><p>Or equivalently:</p><pre><code class="language-julia hljs">path = perfect_foresight(spec; T_periods=100, shock_path=shock_matrix)</code></pre><table><tr><th style="text-align: right">Keyword</th><th style="text-align: right">Type</th><th style="text-align: right">Default</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>T_periods</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right"><code>100</code></td><td style="text-align: right">Number of periods</td></tr><tr><td style="text-align: right"><code>shock_path</code></td><td style="text-align: right"><code>Matrix</code></td><td style="text-align: right">zeros</td><td style="text-align: right"><span>$T \times n_{shocks}$</span> shock sequence</td></tr><tr><td style="text-align: right"><code>max_iter</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right"><code>100</code></td><td style="text-align: right">Newton iteration limit</td></tr><tr><td style="text-align: right"><code>tol</code></td><td style="text-align: right"><code>Real</code></td><td style="text-align: right"><span>$10^{-8}$</span></td><td style="text-align: right">Convergence tolerance</td></tr></table><div class="admonition is-info" id="Technical-Note-b06b5a1a3aab46e7"><header class="admonition-header">Technical Note<a class="admonition-anchor" href="#Technical-Note-b06b5a1a3aab46e7" title="Permalink"></a></header><div class="admonition-body"><p>Uses a Newton solver with a sparse block-tridiagonal Jacobian. The system stacks all <span>$T$</span> periods into a single nonlinear system and solves by iterating <span>$x^{(k+1)} = x^{(k)} - J^{-1} F(x^{(k)})$</span> where <span>$J$</span> exploits the block-tridiagonal sparsity pattern for efficiency.</p></div></div><h3 id="Return-Value-5"><a class="docs-heading-anchor" href="#Return-Value-5">Return Value</a><a class="docs-heading-anchor-permalink" href="#Return-Value-5" title="Permalink"></a></h3><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Type</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>path</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right"><span>$T \times n_{endog}$</span> level values</td></tr><tr><td style="text-align: right"><code>deviations</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right"><span>$T \times n_{endog}$</span> deviations from SS</td></tr><tr><td style="text-align: right"><code>converged</code></td><td style="text-align: right"><code>Bool</code></td><td style="text-align: right">Newton convergence flag</td></tr><tr><td style="text-align: right"><code>iterations</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Newton iterations used</td></tr><tr><td style="text-align: right"><code>spec</code></td><td style="text-align: right"><code>DSGESpec{T}</code></td><td style="text-align: right">Model specification</td></tr></table><hr/><h2 id="Occasionally-Binding-Constraints-(OccBin)"><a class="docs-heading-anchor" href="#Occasionally-Binding-Constraints-(OccBin)">Occasionally Binding Constraints (OccBin)</a><a id="Occasionally-Binding-Constraints-(OccBin)-1"></a><a class="docs-heading-anchor-permalink" href="#Occasionally-Binding-Constraints-(OccBin)" title="Permalink"></a></h2><p>The OccBin method (Guerrieri &amp; Iacoviello 2015) solves DSGE models with occasionally binding constraints using a piecewise-linear approximation. The idea is that the economy switches between a reference regime (constraint slack) and an alternative regime (constraint binding), and the solution iterates until the regime sequence is self-consistent.</p><h3 id="Parsing-Constraints"><a class="docs-heading-anchor" href="#Parsing-Constraints">Parsing Constraints</a><a id="Parsing-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Parsing-Constraints" title="Permalink"></a></h3><pre><code class="language-julia hljs">constraint = parse_constraint(:(R[t] &gt;= 0), spec)</code></pre><p>Supports <code>&gt;=</code> and <code>&lt;=</code> directions. The variable must exist in <code>spec.endog</code>.</p><h3 id="One-Constraint"><a class="docs-heading-anchor" href="#One-Constraint">One Constraint</a><a id="One-Constraint-1"></a><a class="docs-heading-anchor-permalink" href="#One-Constraint" title="Permalink"></a></h3><p>The typical use case is a zero lower bound on the nominal interest rate:</p><pre><code class="language-julia hljs"># Construct shock path (large negative demand shock)
shocks = zeros(40, spec.n_exog)
shocks[1, 1] = -3.0  # 3 std dev negative shock

# Solve with ZLB constraint
occ_sol = occbin_solve(spec, constraint; shock_path=shocks)
println(occ_sol)
plot_result(occ_sol)</code></pre><table><tr><th style="text-align: right">Keyword</th><th style="text-align: right">Type</th><th style="text-align: right">Default</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>shock_path</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right">zeros</td><td style="text-align: right"><span>$T \times n_{shocks}$</span> shock sequence</td></tr><tr><td style="text-align: right"><code>nperiods</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right"><code>size(shock_path, 1)</code></td><td style="text-align: right">Number of periods</td></tr><tr><td style="text-align: right"><code>maxiter</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right"><code>100</code></td><td style="text-align: right">Max guess-and-verify iterations</td></tr></table><div class="admonition is-info" id="Technical-Note-24d88db1ea5cbdf5"><header class="admonition-header">Technical Note<a class="admonition-anchor" href="#Technical-Note-24d88db1ea5cbdf5" title="Permalink"></a></header><div class="admonition-body"><p><strong>Guess-and-verify algorithm:</strong></p><ol><li>Solve the unconstrained (reference) model and the alternative (binding) model</li><li>Guess an initial regime sequence (all slack)</li><li>Compute time-varying decision rules via backward iteration from the terminal period</li><li>Simulate forward using the time-varying rules</li><li>Check whether the constraint is satisfied –- update the regime guess</li><li>Repeat until the regime sequence converges</li></ol></div></div><h3 id="Step-by-Step-Walkthrough"><a class="docs-heading-anchor" href="#Step-by-Step-Walkthrough">Step-by-Step Walkthrough</a><a id="Step-by-Step-Walkthrough-1"></a><a class="docs-heading-anchor-permalink" href="#Step-by-Step-Walkthrough" title="Permalink"></a></h3><p>To understand the guess-and-verify algorithm, trace through a ZLB example:</p><pre><code class="language-julia hljs">using MacroEconometricModels

spec = @dsge begin
    parameters: β = 0.99, σ_c = 1.0, κ = 0.3, φ_π = 1.5, φ_y = 0.5,
                ρ_d = 0.8, σ_d = 0.01
    endogenous: y, π, R, d
    exogenous: ε_d

    y[t] = y[t+1] - (1 / σ_c) * (R[t] - π[t+1]) + d[t]
    π[t] = β * π[t+1] + κ * y[t]
    R[t] = φ_π * π[t] + φ_y * y[t]
    d[t] = ρ_d * d[t-1] + σ_d * ε_d[t]
end

constraint = parse_constraint(:(R[t] &gt;= 0), spec)

# Large negative demand shock pushes economy to ZLB
shocks = zeros(60, 1)
shocks[1, 1] = -8.0

occ_sol = occbin_solve(spec, constraint; shock_path=shocks)

# Inspect convergence
println(&quot;Converged: &quot;, occ_sol.converged)
println(&quot;Iterations: &quot;, occ_sol.iterations)

# Regime history: 0 = slack, 1 = binding
println(&quot;Binding periods: &quot;, findall(vec(occ_sol.regime_history[:, 1]) .== 1))

# Compare linear vs piecewise paths for the interest rate (variable 3)
println(&quot;Linear R (first 10):     &quot;, round.(occ_sol.linear_path[1:10, 3], digits=4))
println(&quot;Piecewise R (first 10):  &quot;, round.(occ_sol.piecewise_path[1:10, 3], digits=4))</code></pre><p>The piecewise path clamps <code>R</code> at zero during binding periods, while the linear path allows it to go negative. The output amplification in <code>y</code> and <code>π</code> during binding periods reflects the inability of monetary policy to respond.</p><h3 id="Two-Constraints"><a class="docs-heading-anchor" href="#Two-Constraints">Two Constraints</a><a id="Two-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Two-Constraints" title="Permalink"></a></h3><p>For models with two occasionally binding constraints (4 possible regime combinations):</p><pre><code class="language-julia hljs">c1 = parse_constraint(:(R[t] &gt;= 0), spec)      # ZLB
c2 = parse_constraint(:(debt[t] &lt;= limit), spec) # Debt ceiling

occ_sol = occbin_solve(spec, c1, c2; shock_path=shocks)</code></pre><p>The four regimes are: (0,0) neither binds, (1,0) only first binds, (0,1) only second binds, (1,1) both bind.</p><table><tr><th style="text-align: right">Additional Keyword</th><th style="text-align: right">Type</th><th style="text-align: right">Default</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>curb_retrench</code></td><td style="text-align: right"><code>Bool</code></td><td style="text-align: right"><code>false</code></td><td style="text-align: right">Limit constraint relaxation to 1 period/iteration</td></tr></table><h3 id="OccBin-IRFs"><a class="docs-heading-anchor" href="#OccBin-IRFs">OccBin IRFs</a><a id="OccBin-IRFs-1"></a><a class="docs-heading-anchor-permalink" href="#OccBin-IRFs" title="Permalink"></a></h3><p>Compare linear (unconstrained) and piecewise-linear (constrained) impulse responses:</p><pre><code class="language-julia hljs">occ_irf = occbin_irf(spec, constraint, 1, 40; magnitude=3.0)
plot_result(occ_irf)</code></pre><table><tr><th style="text-align: right">Keyword</th><th style="text-align: right">Type</th><th style="text-align: right">Default</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>magnitude</code></td><td style="text-align: right"><code>Real</code></td><td style="text-align: right"><code>1.0</code></td><td style="text-align: right">Shock size (standard deviations)</td></tr><tr><td style="text-align: right"><code>maxiter</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right"><code>100</code></td><td style="text-align: right">Max guess-and-verify iterations</td></tr></table><h3 id="OccBin-Return-Values"><a class="docs-heading-anchor" href="#OccBin-Return-Values">OccBin Return Values</a><a id="OccBin-Return-Values-1"></a><a class="docs-heading-anchor-permalink" href="#OccBin-Return-Values" title="Permalink"></a></h3><p><strong><code>OccBinSolution{T}</code>:</strong></p><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Type</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>linear_path</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right"><span>$T \times n$</span> unconstrained path</td></tr><tr><td style="text-align: right"><code>piecewise_path</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right"><span>$T \times n$</span> constrained path</td></tr><tr><td style="text-align: right"><code>steady_state</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">Steady-state values</td></tr><tr><td style="text-align: right"><code>regime_history</code></td><td style="text-align: right"><code>Matrix{Int}</code></td><td style="text-align: right"><span>$T \times n_c$</span> regime indicators (0=slack, 1=binding)</td></tr><tr><td style="text-align: right"><code>converged</code></td><td style="text-align: right"><code>Bool</code></td><td style="text-align: right">Convergence flag</td></tr><tr><td style="text-align: right"><code>iterations</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Guess-and-verify iterations</td></tr></table><p><strong><code>OccBinIRF{T}</code>:</strong></p><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Type</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>linear</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right"><span>$H \times n$</span> linear IRF</td></tr><tr><td style="text-align: right"><code>piecewise</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right"><span>$H \times n$</span> piecewise IRF</td></tr><tr><td style="text-align: right"><code>regime_history</code></td><td style="text-align: right"><code>Matrix{Int}</code></td><td style="text-align: right"><span>$H \times n_c$</span> regime indicators</td></tr><tr><td style="text-align: right"><code>shock_name</code></td><td style="text-align: right"><code>String</code></td><td style="text-align: right">Name of shocked variable</td></tr></table><hr/><h2 id="Complete-Example"><a class="docs-heading-anchor" href="#Complete-Example">Complete Example</a><a id="Complete-Example-1"></a><a class="docs-heading-anchor-permalink" href="#Complete-Example" title="Permalink"></a></h2><p>A 3-equation New Keynesian model with an IS curve, Phillips curve, and Taylor rule –- estimated and subjected to a ZLB constraint.</p><pre><code class="language-julia hljs">using MacroEconometricModels, Random
Random.seed!(42)

# ── 1. Model specification ──
spec = @dsge begin
    parameters: β = 0.99, σ_c = 1.0, κ = 0.3, φ_π = 1.5, φ_y = 0.5,
                ρ_d = 0.8, ρ_s = 0.7, σ_d = 0.01, σ_s = 0.01
    endogenous: y, π, R, d, s
    exogenous: ε_d, ε_s

    # IS curve (demand)
    y[t] = y[t+1] - (1 / σ_c) * (R[t] - π[t+1]) + d[t]

    # Phillips curve (supply)
    π[t] = β * π[t+1] + κ * y[t] + s[t]

    # Taylor rule
    R[t] = φ_π * π[t] + φ_y * y[t]

    # Demand shock
    d[t] = ρ_d * d[t-1] + σ_d * ε_d[t]

    # Supply shock
    s[t] = ρ_s * s[t-1] + σ_s * ε_s[t]
end

# ── 2. Solve ──
sol = solve(spec)
println(&quot;Determined: &quot;, is_determined(sol))
println(&quot;Stable: &quot;, is_stable(sol))

# ── 3. Impulse responses ──
irf_result = irf(sol, 40)
plot_result(irf_result)

# ── 4. FEVD ──
fevd_result = fevd(sol, 40)
plot_result(fevd_result)

# ── 5. Simulation ──
Y_sim = simulate(sol, 200; rng=Random.MersenneTwister(42))

# ── 6. Analytical moments ──
Sigma = solve_lyapunov(sol.G1, sol.impact)
m = analytical_moments(sol; lags=2)
println(&quot;Unconditional variance of output: &quot;, Sigma[1, 1])

# ── 7. Estimation (IRF matching) ──
# est = estimate_dsge(spec, Y_data, [:κ, :φ_π, :ρ_d];
#                     method=:irf_matching, var_lags=4, irf_horizon=20)
# report(est)

# ── 8. OccBin: Zero lower bound ──
constraint = parse_constraint(:(R[t] &gt;= 0), spec)

shocks = zeros(40, 2)
shocks[1, 1] = -3.0  # Large negative demand shock

occ_sol = occbin_solve(spec, constraint; shock_path=shocks)
println(occ_sol)

occ_irf = occbin_irf(spec, constraint, 1, 40; magnitude=3.0)
plot_result(occ_irf)</code></pre><p>The OccBin IRF plot shows how the ZLB amplifies the output decline: the constrained path (red) drops further than the linear path (blue) because the interest rate cannot go below zero to stimulate the economy.</p><hr/><h2 id="Common-Pitfalls"><a class="docs-heading-anchor" href="#Common-Pitfalls">Common Pitfalls</a><a id="Common-Pitfalls-1"></a><a class="docs-heading-anchor-permalink" href="#Common-Pitfalls" title="Permalink"></a></h2><h3 id="Wrong-Steady-State"><a class="docs-heading-anchor" href="#Wrong-Steady-State">Wrong Steady State</a><a id="Wrong-Steady-State-1"></a><a class="docs-heading-anchor-permalink" href="#Wrong-Steady-State" title="Permalink"></a></h3><p>If the numerical solver converges to the wrong steady state, the linearization will be incorrect. Prefer analytical steady states via the <code>steady_state = begin ... end</code> block when possible.</p><pre><code class="language-julia hljs"># Check that residuals are near zero
spec = compute_steady_state(spec)
println(&quot;Steady state: &quot;, spec.steady_state)</code></pre><h3 id="Indeterminate-Model"><a class="docs-heading-anchor" href="#Indeterminate-Model">Indeterminate Model</a><a id="Indeterminate-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Indeterminate-Model" title="Permalink"></a></h3><p>If <code>is_determined(sol)</code> returns <code>false</code>, the model has sunspot equilibria. Common fix: ensure the Taylor principle holds (<span>$\phi_\pi &gt; 1$</span>).</p><h3 id="Non-Convergence-in-Estimation"><a class="docs-heading-anchor" href="#Non-Convergence-in-Estimation">Non-Convergence in Estimation</a><a id="Non-Convergence-in-Estimation-1"></a><a class="docs-heading-anchor-permalink" href="#Non-Convergence-in-Estimation" title="Permalink"></a></h3><p>If <code>estimate_dsge</code> doesn&#39;t converge:</p><ul><li><strong>Narrow the parameter space</strong> with <code>bounds</code> via <code>ParameterTransform</code></li><li><strong>Try different starting values</strong> –- the optimizer may be stuck in a local minimum</li><li><strong>Check identification</strong> –- some parameters may not be identified from your chosen moments</li><li><strong>Increase horizon</strong> –- for IRF matching, a longer <code>irf_horizon</code> may help</li></ul><h3 id="Equation-Count-Mismatch"><a class="docs-heading-anchor" href="#Equation-Count-Mismatch">Equation Count Mismatch</a><a id="Equation-Count-Mismatch-1"></a><a class="docs-heading-anchor-permalink" href="#Equation-Count-Mismatch" title="Permalink"></a></h3><p>The <code>@dsge</code> macro requires exactly one equation per endogenous variable. If you need an interest rate smoothing rule, combine the Taylor rule and smoothing into one equation rather than writing two equations for <code>R</code>.</p><hr/><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><ul><li>Blanchard, O. J., &amp; Kahn, C. M. (1980). The Solution of Linear Difference Models under Rational Expectations. <em>Econometrica</em>, 48(5), 1305–1311.</li><li>Christiano, L. J., Eichenbaum, M., &amp; Evans, C. L. (2005). Nominal Rigidities and the Dynamic Effects of a Shock to Monetary Policy. <em>Journal of Political Economy</em>, 113(1), 1–45.</li><li>Guerrieri, L., &amp; Iacoviello, M. (2015). OccBin: A Toolkit for Solving Dynamic Models with Occasionally Binding Constraints Easily. <em>Journal of Monetary Economics</em>, 70, 22–38.</li><li>Hamilton, J. D. (1994). <em>Time Series Analysis</em>. Princeton University Press.</li><li>Hansen, L. P. (1982). Large Sample Properties of Generalized Method of Moments Estimators. <em>Econometrica</em>, 50(4), 1029–1054.</li><li>Hansen, L. P., &amp; Singleton, K. J. (1982). Generalized Instrumental Variables Estimation of Nonlinear Rational Expectations Models. <em>Econometrica</em>, 50(5), 1269–1286.</li><li>Sims, C. A. (2002). Solving Linear Rational Expectations Models. <em>Computational Economics</em>, 20(1–2), 1–20.</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../pvar/">« Panel VAR</a><a class="docs-footer-nextpage" href="../innovation_accounting/">Innovation Accounting »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.17.0 on <span class="colophon-date" title="Wednesday 25 February 2026 00:21">Wednesday 25 February 2026</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
