<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>DSGE Models · MacroEconometricModels.jl</title><meta name="title" content="DSGE Models · MacroEconometricModels.jl"/><meta property="og:title" content="DSGE Models · MacroEconometricModels.jl"/><meta property="twitter:title" content="DSGE Models · MacroEconometricModels.jl"/><meta name="description" content="Documentation for MacroEconometricModels.jl."/><meta property="og:description" content="Documentation for MacroEconometricModels.jl."/><meta property="twitter:description" content="Documentation for MacroEconometricModels.jl."/><meta property="og:url" content="https://FriedmanJP.github.io/MacroEconometricModels.jl/dsge/"/><meta property="twitter:url" content="https://FriedmanJP.github.io/MacroEconometricModels.jl/dsge/"/><link rel="canonical" href="https://FriedmanJP.github.io/MacroEconometricModels.jl/dsge/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/custom.css" rel="stylesheet" type="text/css"/><script src="../assets/theme-toggle.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MacroEconometricModels.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../data/">Data Management</a></li><li><span class="tocitem">Univariate Models</span><ul><li><a class="tocitem" href="../filters/">Time Series Filters</a></li><li><a class="tocitem" href="../arima/">ARIMA</a></li><li><a class="tocitem" href="../volatility/">Volatility Models</a></li></ul></li><li><span class="tocitem">Multivariate Models</span><ul><li><a class="tocitem" href="../manual/">VAR</a></li><li><a class="tocitem" href="../bayesian/">Bayesian VAR</a></li><li><a class="tocitem" href="../vecm/">VECM</a></li><li><a class="tocitem" href="../lp/">Local Projections</a></li><li><a class="tocitem" href="../factormodels/">Factor Models</a></li></ul></li><li><span class="tocitem">Panel Models</span><ul><li><a class="tocitem" href="../pvar/">Panel VAR</a></li></ul></li><li class="is-active"><a class="tocitem" href>DSGE Models</a><ul class="internal"><li><a class="tocitem" href="#Quick-Start"><span>Quick Start</span></a></li><li><a class="tocitem" href="#Model-Specification"><span>Model Specification</span></a></li><li><a class="tocitem" href="#Steady-State"><span>Steady State</span></a></li><li><a class="tocitem" href="#Linearization"><span>Linearization</span></a></li><li><a class="tocitem" href="#Solution-Methods"><span>Solution Methods</span></a></li><li><a class="tocitem" href="#First-Order-Solvers"><span>First-Order Solvers</span></a></li><li><a class="tocitem" href="#Second-Order-Perturbation"><span>Second-Order Perturbation</span></a></li><li><a class="tocitem" href="#Pruning"><span>Pruning</span></a></li><li><a class="tocitem" href="#Chebyshev-Projection"><span>Chebyshev Projection</span></a></li><li><a class="tocitem" href="#Policy-Function-Iteration"><span>Policy Function Iteration</span></a></li><li><a class="tocitem" href="#Simulation-and-IRFs"><span>Simulation and IRFs</span></a></li><li><a class="tocitem" href="#Estimation"><span>Estimation</span></a></li><li><a class="tocitem" href="#Perfect-Foresight"><span>Perfect Foresight</span></a></li><li><a class="tocitem" href="#Occasionally-Binding-Constraints-(OccBin)"><span>Occasionally Binding Constraints (OccBin)</span></a></li><li><a class="tocitem" href="#Complete-Example"><span>Complete Example</span></a></li><li><a class="tocitem" href="#Common-Pitfalls"><span>Common Pitfalls</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../innovation_accounting/">Innovation Accounting</a></li><li><a class="tocitem" href="../nowcast/">Nowcasting</a></li><li><a class="tocitem" href="../nongaussian/">Statistical Identification</a></li><li><a class="tocitem" href="../hypothesis_tests/">Hypothesis Tests</a></li><li><a class="tocitem" href="../plotting/">Visualization</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><span class="tocitem">API Reference</span><ul><li><a class="tocitem" href="../api/">Overview</a></li><li><a class="tocitem" href="../api_types/">Types</a></li><li><a class="tocitem" href="../api_functions/">Functions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>DSGE Models</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>DSGE Models</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/FriedmanJP/MacroEconometricModels.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/main/docs/src/dsge.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="DSGE-Models"><a class="docs-heading-anchor" href="#DSGE-Models">DSGE Models</a><a id="DSGE-Models-1"></a><a class="docs-heading-anchor-permalink" href="#DSGE-Models" title="Permalink"></a></h1><p><strong>MacroEconometricModels.jl</strong> provides a complete toolkit for specifying, solving, simulating, and estimating Dynamic Stochastic General Equilibrium (DSGE) models. The package covers the full workflow from model definition to structural estimation:</p><ul><li><strong>Specification</strong>: The <code>@dsge</code> macro provides a domain-specific language for writing equilibrium conditions with time-indexed variables</li><li><strong>Steady State</strong>: Analytical or numerical steady-state computation with two-phase optimization</li><li><strong>Linearization</strong>: Automatic first-order approximation via numerical Jacobians in the Sims (2002) canonical form</li><li><strong>Solution Methods</strong>: Four first-order solvers (Gensys, Blanchard-Kahn, Klein, perturbation) plus second-order perturbation with pruning, Chebyshev projection, and policy function iteration</li><li><strong>Simulation and IRFs</strong>: Stochastic and pruned simulation, analytical and generalized impulse responses, FEVD, unconditional moments via Lyapunov equation</li><li><strong>Estimation</strong>: Four GMM-based methods for estimating deep structural parameters from data</li><li><strong>Nonlinear Extensions</strong>: Perfect foresight paths, OccBin occasionally binding constraints, constrained optimization via JuMP/Ipopt (NLP) and PATH (MCP)</li></ul><p>All results integrate seamlessly with <code>plot_result()</code> for interactive D3.js visualization and <code>report()</code> for publication-quality output.</p><h2 id="Quick-Start"><a class="docs-heading-anchor" href="#Quick-Start">Quick Start</a><a id="Quick-Start-1"></a><a class="docs-heading-anchor-permalink" href="#Quick-Start" title="Permalink"></a></h2><p><strong>Recipe 1: Solve and plot IRFs</strong></p><pre><code class="language-julia hljs">using MacroEconometricModels, Random
Random.seed!(42)

# Specify a simple RBC model
spec = @dsge begin
    parameters: β = 0.99, α = 0.36, δ = 0.025, ρ = 0.9, σ = 0.01
    endogenous: Y, C, K, A
    exogenous: ε_A

    Y[t] = A[t] * K[t-1]^α
    C[t] + K[t] = Y[t] + (1 - δ) * K[t-1]
    1 = β * (C[t] / C[t+1]) * (α * A[t+1] * K[t]^(α - 1) + 1 - δ)
    A[t] = ρ * A[t-1] + σ * ε_A[t]

    steady_state = begin
        A_ss = 1.0
        K_ss = (α * β / (1 - β * (1 - δ)))^(1 / (1 - α))
        Y_ss = K_ss^α
        C_ss = Y_ss - δ * K_ss
        [Y_ss, C_ss, K_ss, A_ss]
    end
end

sol = solve(spec)
result = irf(sol, 40)
plot_result(result)</code></pre><p><strong>Recipe 2: Second-order perturbation with pruning</strong></p><pre><code class="language-julia hljs">psol = perturbation_solver(spec; order=2)
Y_sim = simulate(psol, 1000)  # pruned simulation (Kim et al. 2008)
girf = irf(psol, 40; irf_type=:girf, n_draws=500)</code></pre><p><strong>Recipe 3: Estimate with GMM</strong></p><pre><code class="language-julia hljs">est = estimate_dsge(spec, Y_data, [:β, :α, :ρ];
                    method=:irf_matching, var_lags=4, irf_horizon=20)
report(est)</code></pre><p><strong>Recipe 4: OccBin with ZLB</strong></p><pre><code class="language-julia hljs">constraint = parse_constraint(:(R[t] &gt;= 0), spec)
occ_sol = occbin_solve(spec, constraint; shock_path=shocks)
occ_irf = occbin_irf(spec, constraint, 1, 40)
plot_result(occ_irf)</code></pre><p><strong>Recipe 5: Chebyshev projection</strong></p><pre><code class="language-julia hljs">proj = collocation_solver(spec; degree=5, grid=:tensor)
y = evaluate_policy(proj, x_state)
err = max_euler_error(proj)</code></pre><p><strong>Recipe 6: Constrained steady state (JuMP/Ipopt)</strong></p><pre><code class="language-julia hljs">import JuMP, Ipopt
bound = variable_bound(:i, lower=0.0)
spec_c = compute_steady_state(spec, [bound])</code></pre><hr/><h2 id="Model-Specification"><a class="docs-heading-anchor" href="#Model-Specification">Model Specification</a><a id="Model-Specification-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Specification" title="Permalink"></a></h2><p>The <code>@dsge</code> macro provides a domain-specific language for specifying DSGE models. It parses the model into a <code>DSGESpec{T}</code> object containing equations, parameters, and variable declarations.</p><h3 id="Syntax"><a class="docs-heading-anchor" href="#Syntax">Syntax</a><a id="Syntax-1"></a><a class="docs-heading-anchor-permalink" href="#Syntax" title="Permalink"></a></h3><pre><code class="language-julia hljs">spec = @dsge begin
    parameters: β = 0.99, α = 0.36, δ = 0.025, ρ = 0.9, σ = 0.01
    endogenous: Y, C, K, A
    exogenous: ε_A

    # Equations (one per endogenous variable)
    Y[t] = A[t] * K[t-1]^α
    C[t] + K[t] = Y[t] + (1 - δ) * K[t-1]
    1 = β * (C[t] / C[t+1]) * (α * A[t+1] * K[t]^(α - 1) + 1 - δ)
    A[t] = ρ * A[t-1] + σ * ε_A[t]
end</code></pre><h3 id="Blocks"><a class="docs-heading-anchor" href="#Blocks">Blocks</a><a id="Blocks-1"></a><a class="docs-heading-anchor-permalink" href="#Blocks" title="Permalink"></a></h3><table><tr><th style="text-align: right">Block</th><th style="text-align: right">Syntax</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>parameters:</code></td><td style="text-align: right"><code>name = value, ...</code></td><td style="text-align: right">Calibrated parameters with default values</td></tr><tr><td style="text-align: right"><code>endogenous:</code></td><td style="text-align: right"><code>var1, var2, ...</code></td><td style="text-align: right">Endogenous variable names</td></tr><tr><td style="text-align: right"><code>exogenous:</code></td><td style="text-align: right"><code>shock1, shock2, ...</code></td><td style="text-align: right">Exogenous shock names</td></tr><tr><td style="text-align: right"><code>steady_state</code></td><td style="text-align: right"><code>= begin ... [y_ss] end</code></td><td style="text-align: right">Optional analytical steady-state function (must return vector)</td></tr><tr><td style="text-align: right"><code>varnames:</code></td><td style="text-align: right"><code>[&quot;Label 1&quot;, &quot;Label 2&quot;, ...]</code></td><td style="text-align: right">Optional display labels for variables</td></tr></table><h3 id="Time-Subscripts"><a class="docs-heading-anchor" href="#Time-Subscripts">Time Subscripts</a><a id="Time-Subscripts-1"></a><a class="docs-heading-anchor-permalink" href="#Time-Subscripts" title="Permalink"></a></h3><table><tr><th style="text-align: right">Notation</th><th style="text-align: right">Meaning</th></tr><tr><td style="text-align: right"><code>var[t]</code></td><td style="text-align: right">Current period value</td></tr><tr><td style="text-align: right"><code>var[t-1]</code></td><td style="text-align: right">One-period lag (predetermined variable)</td></tr><tr><td style="text-align: right"><code>var[t+1]</code></td><td style="text-align: right">One-period lead (forward-looking / jump variable)</td></tr></table><p>Variables with <code>[t+1]</code> subscripts generate expectation errors in the Sims canonical form. The number of forward-looking equations determines the dimension of the <span>$\Pi$</span> matrix and, via the Blanchard-Kahn condition, the number of unstable eigenvalues required for determinacy.</p><div class="admonition is-info" id="Technical-Note-303a698eebb1d600"><header class="admonition-header">Technical Note<a class="admonition-anchor" href="#Technical-Note-303a698eebb1d600" title="Permalink"></a></header><div class="admonition-body"><p>Equations are written as <code>LHS = RHS</code> where both sides can contain endogenous variables at different time subscripts. The <code>@dsge</code> macro rearranges each equation into residual form <span>$f(y_t, y_{t-1}, y_{t+1}, \varepsilon_t, \theta) = 0$</span> via <code>LHS - RHS</code>. The number of equations must equal the number of endogenous variables. Timing convention: <span>$K_{t}$</span> chosen at time <span>$t$</span> appears as <code>K[t]</code>; <span>$K_{t-1}$</span> (beginning-of-period capital) as <code>K[t-1]</code>.</p></div></div><h3 id="Return-Value"><a class="docs-heading-anchor" href="#Return-Value">Return Value</a><a id="Return-Value-1"></a><a class="docs-heading-anchor-permalink" href="#Return-Value" title="Permalink"></a></h3><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Type</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>endog</code></td><td style="text-align: right"><code>Vector{Symbol}</code></td><td style="text-align: right">Endogenous variable names</td></tr><tr><td style="text-align: right"><code>exog</code></td><td style="text-align: right"><code>Vector{Symbol}</code></td><td style="text-align: right">Exogenous shock names</td></tr><tr><td style="text-align: right"><code>params</code></td><td style="text-align: right"><code>Vector{Symbol}</code></td><td style="text-align: right">Parameter names</td></tr><tr><td style="text-align: right"><code>param_values</code></td><td style="text-align: right"><code>Dict{Symbol,T}</code></td><td style="text-align: right">Calibrated values</td></tr><tr><td style="text-align: right"><code>equations</code></td><td style="text-align: right"><code>Vector{Expr}</code></td><td style="text-align: right">Raw equation expressions</td></tr><tr><td style="text-align: right"><code>n_endog</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Number of endogenous variables</td></tr><tr><td style="text-align: right"><code>n_exog</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Number of exogenous shocks</td></tr><tr><td style="text-align: right"><code>n_expect</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Number of expectation errors</td></tr><tr><td style="text-align: right"><code>forward_indices</code></td><td style="text-align: right"><code>Vector{Int}</code></td><td style="text-align: right">Indices of forward-looking equations</td></tr><tr><td style="text-align: right"><code>steady_state</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">Steady-state values</td></tr><tr><td style="text-align: right"><code>varnames</code></td><td style="text-align: right"><code>Vector{String}</code></td><td style="text-align: right">Display names</td></tr></table><hr/><h2 id="Steady-State"><a class="docs-heading-anchor" href="#Steady-State">Steady State</a><a id="Steady-State-1"></a><a class="docs-heading-anchor-permalink" href="#Steady-State" title="Permalink"></a></h2><p>The steady state <span>$\bar{y}$</span> satisfies the equilibrium system in the absence of shocks:</p><p class="math-container">\[f(\bar{y}, \bar{y}, \bar{y}, 0, \theta) = 0\]</p><p>For the RBC model above, the analytical steady state is:</p><p class="math-container">\[\bar{A} = 1, \quad \bar{K} = \left(\frac{\alpha\beta}{1 - \beta(1-\delta)}\right)^{\frac{1}{1-\alpha}}, \quad \bar{Y} = \bar{K}^\alpha, \quad \bar{C} = \bar{Y} - \delta\bar{K}\]</p><h3 id="Numerical-Computation"><a class="docs-heading-anchor" href="#Numerical-Computation">Numerical Computation</a><a id="Numerical-Computation-1"></a><a class="docs-heading-anchor-permalink" href="#Numerical-Computation" title="Permalink"></a></h3><pre><code class="language-julia hljs">spec = compute_steady_state(spec)
println(&quot;Steady state: &quot;, spec.steady_state)</code></pre><p><code>compute_steady_state</code> uses a two-phase optimizer: Nelder-Mead for robustness (derivative-free global exploration), then L-BFGS for refinement. It minimizes the sum of squared residuals <span>$\sum_i f_i(\bar{y})^2$</span>.</p><table><tr><th style="text-align: right">Keyword</th><th style="text-align: right">Type</th><th style="text-align: right">Default</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>initial_guess</code></td><td style="text-align: right"><code>Vector</code></td><td style="text-align: right"><code>nothing</code></td><td style="text-align: right">Starting point (default: ones)</td></tr><tr><td style="text-align: right"><code>method</code></td><td style="text-align: right"><code>Symbol</code></td><td style="text-align: right"><code>:auto</code></td><td style="text-align: right"><code>:auto</code> (NelderMead then LBFGS) or <code>:analytical</code></td></tr></table><h3 id="Analytical-Steady-State"><a class="docs-heading-anchor" href="#Analytical-Steady-State">Analytical Steady State</a><a id="Analytical-Steady-State-1"></a><a class="docs-heading-anchor-permalink" href="#Analytical-Steady-State" title="Permalink"></a></h3><p>For models where the steady state has a closed-form solution, specify it in a <code>steady_state = begin ... end</code> block. The block must return a vector matching the endogenous variable ordering:</p><pre><code class="language-julia hljs">spec = @dsge begin
    parameters: β = 0.99, α = 0.36, δ = 0.025, ρ = 0.9, σ = 0.01
    endogenous: Y, C, K, A
    exogenous: ε_A

    Y[t] = A[t] * K[t-1]^α
    C[t] + K[t] = Y[t] + (1 - δ) * K[t-1]
    1 = β * (C[t] / C[t+1]) * (α * A[t+1] * K[t]^(α - 1) + 1 - δ)
    A[t] = ρ * A[t-1] + σ * ε_A[t]

    steady_state = begin
        A_ss = 1.0
        K_ss = (α * β / (1 - β * (1 - δ)))^(1 / (1 - α))
        Y_ss = K_ss^α
        C_ss = Y_ss - δ * K_ss
        [Y_ss, C_ss, K_ss, A_ss]
    end
end</code></pre><p>When the <code>steady_state</code> block is provided, <code>compute_steady_state</code> (or <code>solve</code>) uses it directly and validates the result against the equations.</p><h3 id="Constrained-Steady-State-(JuMP/Ipopt)"><a class="docs-heading-anchor" href="#Constrained-Steady-State-(JuMP/Ipopt)">Constrained Steady State (JuMP/Ipopt)</a><a id="Constrained-Steady-State-(JuMP/Ipopt)-1"></a><a class="docs-heading-anchor-permalink" href="#Constrained-Steady-State-(JuMP/Ipopt)" title="Permalink"></a></h3><p>For models with variable bounds –- such as a zero lower bound on the nominal interest rate or non-negativity of consumption –- the steady state can be computed as a constrained optimization problem using JuMP and Ipopt:</p><pre><code class="language-julia hljs">import JuMP, Ipopt

# ZLB: interest rate cannot go below zero
bound = variable_bound(:R, lower=0.0)

# Solve constrained steady state
spec = compute_steady_state(spec, [bound])</code></pre><p>The solver minimizes the sum of squared equilibrium residuals subject to the variable bounds. It uses Ipopt (Interior Point Optimizer) via JuMP&#39;s automatic differentiation.</p><h3 id="Constrained-Steady-State-(PATH-MCP)"><a class="docs-heading-anchor" href="#Constrained-Steady-State-(PATH-MCP)">Constrained Steady State (PATH MCP)</a><a id="Constrained-Steady-State-(PATH-MCP)-1"></a><a class="docs-heading-anchor-permalink" href="#Constrained-Steady-State-(PATH-MCP)" title="Permalink"></a></h3><p>For problems naturally expressed as complementarity conditions –- where a constraint binds if and only if a corresponding equation holds with slack –- the PATH solver formulates the steady state as a Mixed Complementarity Problem (MCP):</p><pre><code class="language-julia hljs">import JuMP, PATHSolver

bound = variable_bound(:R, lower=0.0)
spec = compute_steady_state(spec, [bound]; solver=:path)</code></pre><p>The MCP formulation is: for each variable <span>$i$</span> with lower bound <span>$l_i$</span> and upper bound <span>$u_i$</span>, find <span>$y_i$</span> such that:</p><p class="math-container">\[l_i \leq y_i \leq u_i, \quad f_i(y) \begin{cases} \geq 0 &amp; \text{if } y_i = l_i \\ = 0 &amp; \text{if } l_i &lt; y_i &lt; u_i \\ \leq 0 &amp; \text{if } y_i = u_i \end{cases}\]</p><div class="admonition is-info" id="When-to-use-PATH-vs-Ipopt-781b84431cd3fa0e"><header class="admonition-header">When to use PATH vs Ipopt<a class="admonition-anchor" href="#When-to-use-PATH-vs-Ipopt-781b84431cd3fa0e" title="Permalink"></a></header><div class="admonition-body"><p>Use <strong>PATH</strong> when constraints are box bounds (variable bounds only) and the model has a natural complementarity structure –- for example, a ZLB where <span>$R_t \geq 0$</span> and the Taylor rule holds with equality when <span>$R_t &gt; 0$</span>. Use <strong>Ipopt</strong> when you have general nonlinear inequality constraints or when the complementarity interpretation is not natural.</p></div></div><hr/><h2 id="Linearization"><a class="docs-heading-anchor" href="#Linearization">Linearization</a><a id="Linearization-1"></a><a class="docs-heading-anchor-permalink" href="#Linearization" title="Permalink"></a></h2><p><code>linearize</code> computes a first-order Taylor expansion around the steady state using numerical Jacobians (central differences). It produces the Sims (2002) canonical form:</p><p class="math-container">\[\Gamma_0 \, y_t = \Gamma_1 \, y_{t-1} + C + \Psi \, \varepsilon_t + \Pi \, \eta_t\]</p><p>where <span>$y_t$</span> is the vector of endogenous variables (in deviations from steady state), <span>$\varepsilon_t$</span> is the vector of exogenous shocks, and <span>$\eta_t$</span> is the vector of expectation errors (<span>$\eta_t = y_t - E_{t-1}[y_t]$</span> for forward-looking variables).</p><pre><code class="language-julia hljs">ld = linearize(spec)</code></pre><div class="admonition is-info" id="Technical-Note-e49a285d25d28bb9"><header class="admonition-header">Technical Note<a class="admonition-anchor" href="#Technical-Note-e49a285d25d28bb9" title="Permalink"></a></header><div class="admonition-body"><p>The matrices are computed via central differences with step size <span>$h = \max(10^{-7}, 10^{-7} |y_j|)$</span>. No analytical derivatives are required. <span>$\Gamma_0$</span> contains coefficients on <span>$y_t$</span>, <span>$\Gamma_1$</span> on <span>$y_{t-1}$</span>, <span>$\Psi$</span> on shocks, and <span>$\Pi$</span> selects the forward-looking equations for expectation errors. The matrix pair <span>$(\Gamma_0, \Gamma_1)$</span> defines a generalized eigenvalue problem whose solution governs the dynamics.</p></div></div><h3 id="Return-Value-2"><a class="docs-heading-anchor" href="#Return-Value-2">Return Value</a><a class="docs-heading-anchor-permalink" href="#Return-Value-2" title="Permalink"></a></h3><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Type</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>Gamma0</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right"><span>$n \times n$</span> coefficient on <span>$y_t$</span></td></tr><tr><td style="text-align: right"><code>Gamma1</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right"><span>$n \times n$</span> coefficient on <span>$y_{t-1}$</span></td></tr><tr><td style="text-align: right"><code>C</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right"><span>$n \times 1$</span> constants</td></tr><tr><td style="text-align: right"><code>Psi</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right"><span>$n \times n_{shocks}$</span> shock loading</td></tr><tr><td style="text-align: right"><code>Pi</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right"><span>$n \times n_{expect}$</span> expectation error selection</td></tr><tr><td style="text-align: right"><code>spec</code></td><td style="text-align: right"><code>DSGESpec{T}</code></td><td style="text-align: right">Back-reference to specification</td></tr></table><hr/><h2 id="Solution-Methods"><a class="docs-heading-anchor" href="#Solution-Methods">Solution Methods</a><a id="Solution-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Solution-Methods" title="Permalink"></a></h2><h3 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h3><p><code>solve</code> is the unified entry point for solving linearized DSGE models. It dispatches to the appropriate solver based on the <code>method</code> keyword:</p><pre><code class="language-julia hljs">sol = solve(spec; method=:gensys)</code></pre><p>All first-order solvers produce the same state-space representation:</p><p class="math-container">\[y_t = G_1 \, y_{t-1} + C_{sol} + \text{impact} \cdot \varepsilon_t\]</p><p>where <span>$G_1$</span> is the <span>$n \times n$</span> state transition matrix, <span>$\text{impact}$</span> is the <span>$n \times n_{shocks}$</span> impact matrix, and <span>$C_{sol}$</span> captures constant terms.</p><table><tr><th style="text-align: right">Method</th><th style="text-align: right">Algorithm</th><th style="text-align: right">Reference</th></tr><tr><td style="text-align: right"><code>:gensys</code> (default)</td><td style="text-align: right">QZ decomposition</td><td style="text-align: right">Sims (2002)</td></tr><tr><td style="text-align: right"><code>:blanchard_kahn</code></td><td style="text-align: right">Eigenvalue decomposition</td><td style="text-align: right">Blanchard &amp; Kahn (1980)</td></tr><tr><td style="text-align: right"><code>:klein</code></td><td style="text-align: right">Generalized Schur (QZ) with BK counting</td><td style="text-align: right">Klein (2000)</td></tr><tr><td style="text-align: right"><code>:perturbation</code></td><td style="text-align: right">Higher-order Taylor expansion</td><td style="text-align: right">Schmitt-Grohe &amp; Uribe (2004)</td></tr><tr><td style="text-align: right"><code>:projection</code></td><td style="text-align: right">Chebyshev collocation</td><td style="text-align: right">Judd (1998)</td></tr><tr><td style="text-align: right"><code>:pfi</code></td><td style="text-align: right">Policy function iteration</td><td style="text-align: right">Coleman (1990)</td></tr><tr><td style="text-align: right"><code>:perfect_foresight</code></td><td style="text-align: right">Deterministic Newton solver</td><td style="text-align: right">–-</td></tr></table><p><code>solve</code> automatically calls <code>compute_steady_state</code> and <code>linearize</code> if they have not been called already.</p><h3 id="Choosing-a-Solver"><a class="docs-heading-anchor" href="#Choosing-a-Solver">Choosing a Solver</a><a id="Choosing-a-Solver-1"></a><a class="docs-heading-anchor-permalink" href="#Choosing-a-Solver" title="Permalink"></a></h3><table><tr><th style="text-align: right">Feature needed</th><th style="text-align: right">Recommended</th><th style="text-align: right">Why</th></tr><tr><td style="text-align: right">Standard IRFs, FEVD</td><td style="text-align: right"><code>:gensys</code></td><td style="text-align: right">Robust, handles singularity</td></tr><tr><td style="text-align: right">Simple model, fast</td><td style="text-align: right"><code>:blanchard_kahn</code> or <code>:klein</code></td><td style="text-align: right">Faster eigenvalue decomposition</td></tr><tr><td style="text-align: right">Risk premia, welfare</td><td style="text-align: right"><code>:perturbation</code> (order=2)</td><td style="text-align: right">Captures precautionary effects</td></tr><tr><td style="text-align: right">Large shocks, global</td><td style="text-align: right"><code>:projection</code> or <code>:pfi</code></td><td style="text-align: right">Globally accurate policy functions</td></tr><tr><td style="text-align: right">Occasionally binding</td><td style="text-align: right">OccBin or <code>:pfi</code></td><td style="text-align: right">Handles kinks, complementarity</td></tr><tr><td style="text-align: right">Known future shocks</td><td style="text-align: right"><code>:perfect_foresight</code></td><td style="text-align: right">Exact deterministic path</td></tr></table><h3 id="Determinacy-and-Stability"><a class="docs-heading-anchor" href="#Determinacy-and-Stability">Determinacy and Stability</a><a id="Determinacy-and-Stability-1"></a><a class="docs-heading-anchor-permalink" href="#Determinacy-and-Stability" title="Permalink"></a></h3><p>A rational expectations model has a unique bounded solution (is <strong>determinate</strong>) when the number of unstable eigenvalues equals the number of forward-looking (jump) variables. This is the Blanchard-Kahn (1980) condition:</p><table><tr><th style="text-align: right">Eigenvalue count</th><th style="text-align: right">Result</th><th style="text-align: right">Interpretation</th></tr><tr><td style="text-align: right"><span>$n_{unstable} = n_{forward}$</span></td><td style="text-align: right"><strong>Determinate</strong></td><td style="text-align: right">Unique bounded solution</td></tr><tr><td style="text-align: right"><span>$n_{unstable} &lt; n_{forward}$</span></td><td style="text-align: right"><strong>Indeterminate</strong></td><td style="text-align: right">Multiple solutions, sunspot equilibria</td></tr><tr><td style="text-align: right"><span>$n_{unstable} &gt; n_{forward}$</span></td><td style="text-align: right"><strong>No stable solution</strong></td><td style="text-align: right">No bounded equilibrium</td></tr></table><pre><code class="language-julia hljs">sol = solve(spec; method=:gensys)
println(&quot;Determined: &quot;, is_determined(sol))    # true if eu == [1, 1]
println(&quot;Stable: &quot;, is_stable(sol))             # true if max|eigenvalue(G1)| &lt; 1</code></pre><div class="admonition is-warning" id="Common-cause-of-indeterminacy-77dfafe86f2399ce"><header class="admonition-header">Common cause of indeterminacy<a class="admonition-anchor" href="#Common-cause-of-indeterminacy-77dfafe86f2399ce" title="Permalink"></a></header><div class="admonition-body"><p>The Taylor principle requires that the monetary policy rule respond more than one-for-one to inflation: <span>$\phi_\pi &gt; 1$</span> in the Taylor rule <span>$i_t = \phi_\pi \pi_t + \phi_y \hat{y}_t$</span>. With <span>$\phi_\pi &lt; 1$</span>, the 3-equation New Keynesian model is typically indeterminate. More precisely, determinacy requires <span>$\phi_\pi + \frac{1-\beta}{\kappa}\phi_y &gt; 1$</span>.</p></div></div><h3 id="Diagnosing-Indeterminacy"><a class="docs-heading-anchor" href="#Diagnosing-Indeterminacy">Diagnosing Indeterminacy</a><a id="Diagnosing-Indeterminacy-1"></a><a class="docs-heading-anchor-permalink" href="#Diagnosing-Indeterminacy" title="Permalink"></a></h3><p>When a model fails the Blanchard-Kahn condition or Gensys reports <code>eu[2] = 0</code>, inspect the eigenvalues:</p><pre><code class="language-julia hljs">sol = solve(spec; method=:gensys)
println(&quot;Eigenvalues: &quot;, abs.(sol.eigenvalues))
println(&quot;EU: &quot;, sol.eu)

# Count stable vs unstable roots
n_stable = count(abs.(sol.eigenvalues) .&lt; 1.0)
n_unstable = count(abs.(sol.eigenvalues) .&gt;= 1.0)
n_forward = spec.n_expect

println(&quot;Stable: $n_stable, Unstable: $n_unstable, Forward-looking: $n_forward&quot;)</code></pre><hr/><h2 id="First-Order-Solvers"><a class="docs-heading-anchor" href="#First-Order-Solvers">First-Order Solvers</a><a id="First-Order-Solvers-1"></a><a class="docs-heading-anchor-permalink" href="#First-Order-Solvers" title="Permalink"></a></h2><h3 id="Gensys-(Sims-2002)"><a class="docs-heading-anchor" href="#Gensys-(Sims-2002)">Gensys (Sims 2002)</a><a id="Gensys-(Sims-2002)-1"></a><a class="docs-heading-anchor-permalink" href="#Gensys-(Sims-2002)" title="Permalink"></a></h3><p>The Gensys algorithm solves the linearized system via QZ (generalized Schur) decomposition of the matrix pencil <span>$(\Gamma_0, \Gamma_1)$</span>. It separates stable and unstable generalized eigenvalues to construct the state-space solution. Gensys can handle singular <span>$\Gamma_0$</span> matrices and provides diagnostic output on the existence and uniqueness of the solution.</p><pre><code class="language-julia hljs">sol = solve(spec; method=:gensys)
println(&quot;Existence: &quot;, sol.eu[1] == 1)    # 1 = exists
println(&quot;Uniqueness: &quot;, sol.eu[2] == 1)   # 1 = unique</code></pre><div class="admonition is-info" id="Technical-Note-81f4cd922ad272e"><header class="admonition-header">Technical Note<a class="admonition-anchor" href="#Technical-Note-81f4cd922ad272e" title="Permalink"></a></header><div class="admonition-body"><p>The <code>div</code> keyword (default <span>$1.0 + 10^{-8}$</span>) sets the dividing line between stable and unstable eigenvalues. Eigenvalues with modulus below <code>div</code> are classified as stable. The <code>eu</code> vector reports <code>[existence, uniqueness]</code> where 1 = satisfied, 0 = violated. Use <code>:gensys</code> as the default unless you have a specific reason to prefer another solver.</p></div></div><h3 id="Blanchard-Kahn-(1980)"><a class="docs-heading-anchor" href="#Blanchard-Kahn-(1980)">Blanchard-Kahn (1980)</a><a id="Blanchard-Kahn-(1980)-1"></a><a class="docs-heading-anchor-permalink" href="#Blanchard-Kahn-(1980)" title="Permalink"></a></h3><p>The Blanchard-Kahn method partitions the system into predetermined (state) and forward-looking (jump) variables. It computes the eigenvalue decomposition of <span>$\Gamma_0^{-1} \Gamma_1$</span>, orders eigenvalues by modulus, and checks that the number of unstable roots equals the number of jump variables.</p><pre><code class="language-julia hljs">sol = solve(spec; method=:blanchard_kahn)</code></pre><div class="admonition is-warning" id="Warning-b2c392b3c71d2654"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-b2c392b3c71d2654" title="Permalink"></a></header><div class="admonition-body"><p>The Blanchard-Kahn method requires <span>$\Gamma_0$</span> to be invertible. If <span>$\Gamma_0$</span> is singular (as in some large-scale models), use <code>:gensys</code> or <code>:klein</code> instead.</p></div></div><h3 id="Klein-(2000)"><a class="docs-heading-anchor" href="#Klein-(2000)">Klein (2000)</a><a id="Klein-(2000)-1"></a><a class="docs-heading-anchor-permalink" href="#Klein-(2000)" title="Permalink"></a></h3><p>The Klein solver uses the generalized Schur (QZ) decomposition like Gensys, but applies the Blanchard-Kahn counting condition based on predetermined variables rather than forward-looking equations. It reorders eigenvalues so that stable roots (<span>$|\lambda| &lt; \text{div}$</span>) come first, then checks that <span>$n_{stable} = n_{predetermined}$</span>.</p><pre><code class="language-julia hljs">sol = solve(spec; method=:klein)</code></pre><p>The Klein method is particularly useful for models with a natural partition into predetermined (state) and non-predetermined (control) variables. The partition is detected automatically from the <span>$\Gamma_1$</span> matrix: a variable is predetermined if it has a non-zero column in <span>$\Gamma_1$</span> (i.e., it appears with a lag).</p><h3 id="Return-Value-(All-First-Order-Solvers)"><a class="docs-heading-anchor" href="#Return-Value-(All-First-Order-Solvers)">Return Value (All First-Order Solvers)</a><a id="Return-Value-(All-First-Order-Solvers)-1"></a><a class="docs-heading-anchor-permalink" href="#Return-Value-(All-First-Order-Solvers)" title="Permalink"></a></h3><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Type</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>G1</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right"><span>$n \times n$</span> state transition</td></tr><tr><td style="text-align: right"><code>impact</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right"><span>$n \times n_{shocks}$</span> impact matrix</td></tr><tr><td style="text-align: right"><code>C_sol</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right"><span>$n \times 1$</span> constants</td></tr><tr><td style="text-align: right"><code>eu</code></td><td style="text-align: right"><code>Vector{Int}</code></td><td style="text-align: right"><code>[existence, uniqueness]</code> (1=yes, 0=no)</td></tr><tr><td style="text-align: right"><code>method</code></td><td style="text-align: right"><code>Symbol</code></td><td style="text-align: right">Solver used</td></tr><tr><td style="text-align: right"><code>eigenvalues</code></td><td style="text-align: right"><code>Vector{ComplexF64}</code></td><td style="text-align: right">Generalized eigenvalues</td></tr><tr><td style="text-align: right"><code>spec</code></td><td style="text-align: right"><code>DSGESpec{T}</code></td><td style="text-align: right">Model specification</td></tr><tr><td style="text-align: right"><code>linear</code></td><td style="text-align: right"><code>LinearDSGE{T}</code></td><td style="text-align: right">Linearized form</td></tr></table><hr/><h2 id="Second-Order-Perturbation"><a class="docs-heading-anchor" href="#Second-Order-Perturbation">Second-Order Perturbation</a><a id="Second-Order-Perturbation-1"></a><a class="docs-heading-anchor-permalink" href="#Second-Order-Perturbation" title="Permalink"></a></h2><h3 id="Motivation"><a class="docs-heading-anchor" href="#Motivation">Motivation</a><a id="Motivation-1"></a><a class="docs-heading-anchor-permalink" href="#Motivation" title="Permalink"></a></h3><p>First-order perturbation imposes <strong>certainty equivalence</strong>: the decision rules are linear in the state variables and agents behave as if they live in a world without uncertainty. This means first-order solutions cannot capture:</p><ul><li><strong>Precautionary saving</strong> (agents save more when facing risk)</li><li><strong>Risk premia</strong> (expected excess returns are zero at first order)</li><li><strong>Mean shifts</strong> (the stochastic steady state differs from the deterministic one)</li><li><strong>Welfare comparisons</strong> (second-order utility requires second-order policy)</li></ul><p>The second-order perturbation method (Schmitt-Grohe &amp; Uribe 2004) computes decision rules of the form:</p><p class="math-container">\[z_t = \bar{z} + f_v \, v_t + \tfrac{1}{2} f_{vv} (v_t \otimes v_t) + \tfrac{1}{2} f_{\sigma\sigma} \sigma^2\]</p><p>where <span>$v_t = [x_{t-1}; \varepsilon_t]$</span> stacks lagged states and current shocks, <span>$f_v$</span> is the first-order coefficient, <span>$f_{vv}$</span> is the second-order Kronecker coefficient, and <span>$f_{\sigma\sigma}$</span> is the <strong>variance correction</strong> that shifts the mean of the ergodic distribution.</p><h3 id="Computing-the-Second-Order-Solution"><a class="docs-heading-anchor" href="#Computing-the-Second-Order-Solution">Computing the Second-Order Solution</a><a id="Computing-the-Second-Order-Solution-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-the-Second-Order-Solution" title="Permalink"></a></h3><pre><code class="language-julia hljs">psol = perturbation_solver(spec; order=2)</code></pre><table><tr><th style="text-align: right">Keyword</th><th style="text-align: right">Type</th><th style="text-align: right">Default</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>order</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right"><code>2</code></td><td style="text-align: right">Perturbation order (1 or 2)</td></tr><tr><td style="text-align: right"><code>method</code></td><td style="text-align: right"><code>Symbol</code></td><td style="text-align: right"><code>:gensys</code></td><td style="text-align: right">First-order solver (<code>:gensys</code> or <code>:blanchard_kahn</code>)</td></tr></table><h3 id="Algorithm"><a class="docs-heading-anchor" href="#Algorithm">Algorithm</a><a id="Algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithm" title="Permalink"></a></h3><ol><li><strong>First-order solution</strong>: Solve the linearized system via Gensys or Blanchard-Kahn to obtain <span>$G_1$</span> and the impact matrix</li><li><strong>Variable partition</strong>: Identify state (predetermined) and control (jump) variables from the <span>$\Gamma_1$</span> matrix</li><li><strong>Hessian computation</strong>: Compute all second-derivative tensors <span>$\partial^2 f_i / \partial a_j \partial b_k$</span> via central finite differences across the four argument slots (current, lag, lead, shock)</li><li><strong>Kronecker system</strong>: Assemble and solve the matrix equation <span>$f_c \cdot f_{vv} + f_f \cdot f_{vv} \cdot (M \otimes M) = -\text{RHS}$</span> where <span>$f_c, f_f$</span> are Jacobians with respect to current and lead variables, and <span>$M$</span> is the augmented transition matrix</li><li><strong>Variance correction</strong>: Solve <span>$(f_c + f_f) \cdot f_{\sigma\sigma} = -f_f \cdot f_{vv} \cdot \text{vec}(\eta \eta&#39;)$</span></li></ol><div class="admonition is-info" id="Stochastic-Steady-State-7ffe5f9419657f4d"><header class="admonition-header">Stochastic Steady State<a class="admonition-anchor" href="#Stochastic-Steady-State-7ffe5f9419657f4d" title="Permalink"></a></header><div class="admonition-body"><p>The variance correction <span>$f_{\sigma\sigma}$</span> captures the difference between the deterministic steady state <span>$\bar{z}$</span> and the stochastic steady state <span>$\bar{z}^{(2)} = \bar{z} + \frac{1}{2} f_{\sigma\sigma} \sigma^2$</span>. This mean shift reflects agents&#39; precautionary behavior in the face of uncertainty.</p></div></div><h3 id="Return-Value-3"><a class="docs-heading-anchor" href="#Return-Value-3">Return Value</a><a class="docs-heading-anchor-permalink" href="#Return-Value-3" title="Permalink"></a></h3><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Type</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>order</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Perturbation order</td></tr><tr><td style="text-align: right"><code>gx</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right"><span>$n_y \times n_v$</span> control decision rule</td></tr><tr><td style="text-align: right"><code>hx</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right"><span>$n_x \times n_v$</span> state transition rule</td></tr><tr><td style="text-align: right"><code>gxx</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right"><span>$n_y \times n_v^2$</span> second-order control</td></tr><tr><td style="text-align: right"><code>hxx</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right"><span>$n_x \times n_v^2$</span> second-order state</td></tr><tr><td style="text-align: right"><code>gσσ</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right"><span>$n_y$</span> control variance correction</td></tr><tr><td style="text-align: right"><code>hσσ</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right"><span>$n_x$</span> state variance correction</td></tr><tr><td style="text-align: right"><code>state_indices</code></td><td style="text-align: right"><code>Vector{Int}</code></td><td style="text-align: right">Indices of state variables</td></tr><tr><td style="text-align: right"><code>control_indices</code></td><td style="text-align: right"><code>Vector{Int}</code></td><td style="text-align: right">Indices of control variables</td></tr></table><hr/><h2 id="Pruning"><a class="docs-heading-anchor" href="#Pruning">Pruning</a><a id="Pruning-1"></a><a class="docs-heading-anchor-permalink" href="#Pruning" title="Permalink"></a></h2><h3 id="The-Explosive-Simulation-Problem"><a class="docs-heading-anchor" href="#The-Explosive-Simulation-Problem">The Explosive Simulation Problem</a><a id="The-Explosive-Simulation-Problem-1"></a><a class="docs-heading-anchor-permalink" href="#The-Explosive-Simulation-Problem" title="Permalink"></a></h3><p>Naive simulation of second-order decision rules can generate explosive sample paths. The quadratic terms <span>$f_{vv}(v_t \otimes v_t)$</span> feed back into states, amplifying deviations and causing paths to diverge. This is a well-known problem in the perturbation literature.</p><h3 id="Kim-Kim-Schaumburg-Sims-(2008)-Pruning"><a class="docs-heading-anchor" href="#Kim-Kim-Schaumburg-Sims-(2008)-Pruning">Kim-Kim-Schaumburg-Sims (2008) Pruning</a><a id="Kim-Kim-Schaumburg-Sims-(2008)-Pruning-1"></a><a class="docs-heading-anchor-permalink" href="#Kim-Kim-Schaumburg-Sims-(2008)-Pruning" title="Permalink"></a></h3><p>The pruning method prevents explosions by tracking first-order and second-order components separately:</p><ol><li><strong>First-order state</strong>: <span>$x_t^{(1)} = h_x \cdot x_{t-1}^{(1)} + \eta_x \cdot \varepsilon_t$</span> (standard linear dynamics)</li><li><strong>Second-order correction</strong>: <span>$x_t^{(2)} = h_x \cdot x_{t-1}^{(2)} + \frac{1}{2} h_{xx} (v_t^{(1)} \otimes v_t^{(1)}) + \frac{1}{2} h_{\sigma\sigma}$</span></li><li><strong>Total state</strong>: <span>$x_t = x_t^{(1)} + x_t^{(2)}$</span></li></ol><p>The key insight is that the Kronecker product <span>$v_t \otimes v_t$</span> uses only the <strong>first-order</strong> innovations vector <span>$v_t^{(1)}$</span>, preventing the feedback loop that causes explosions.</p><pre><code class="language-julia hljs">psol = perturbation_solver(spec; order=2)
Y_sim = simulate(psol, 1000)  # automatically uses pruning for order &gt;= 2</code></pre><table><tr><th style="text-align: right">Keyword</th><th style="text-align: right">Type</th><th style="text-align: right">Default</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>shock_draws</code></td><td style="text-align: right"><code>Matrix</code></td><td style="text-align: right"><code>nothing</code></td><td style="text-align: right">Pre-drawn shocks (<span>$T \times n_{shocks}$</span>)</td></tr><tr><td style="text-align: right"><code>rng</code></td><td style="text-align: right"><code>AbstractRNG</code></td><td style="text-align: right"><code>default_rng()</code></td><td style="text-align: right">Random number generator</td></tr><tr><td style="text-align: right"><code>antithetic</code></td><td style="text-align: right"><code>Bool</code></td><td style="text-align: right"><code>false</code></td><td style="text-align: right">Antithetic variates for variance reduction</td></tr></table><hr/><h2 id="Chebyshev-Projection"><a class="docs-heading-anchor" href="#Chebyshev-Projection">Chebyshev Projection</a><a id="Chebyshev-Projection-1"></a><a class="docs-heading-anchor-permalink" href="#Chebyshev-Projection" title="Permalink"></a></h2><h3 id="Motivation-2"><a class="docs-heading-anchor" href="#Motivation-2">Motivation</a><a class="docs-heading-anchor-permalink" href="#Motivation-2" title="Permalink"></a></h3><p>Perturbation methods are local approximations: they are accurate near the steady state but can become unreliable far from it. For models with significant nonlinearities, large shocks, or occasionally binding constraints, <strong>projection methods</strong> provide globally accurate policy functions by approximating the solution over the entire state space.</p><h3 id="Algorithm-2"><a class="docs-heading-anchor" href="#Algorithm-2">Algorithm</a><a class="docs-heading-anchor-permalink" href="#Algorithm-2" title="Permalink"></a></h3><p>The Chebyshev collocation method approximates the policy function <span>$g(x)$</span> as a linear combination of Chebyshev polynomials:</p><p class="math-container">\[g(x) \approx \sum_{i=0}^{n} a_i \, T_i\!\left(\frac{2(x - x_{\min})}{x_{\max} - x_{\min}} - 1\right)\]</p><p>where <span>$T_i$</span> is the <span>$i$</span>-th Chebyshev polynomial and the state <span>$x$</span> is mapped to <span>$[-1, 1]$</span> via an affine transformation. The coefficients <span>$\{a_i\}$</span> are determined by imposing equilibrium at a set of collocation nodes:</p><ol><li><strong>Grid construction</strong>: Build a tensor-product or Smolyak sparse grid of Chebyshev nodes in the state space</li><li><strong>State bounds</strong>: Computed as <span>$\bar{x} \pm \text{scale} \cdot \sigma_x$</span> using the first-order unconditional variance</li><li><strong>Expectation integration</strong>: Approximate <span>$E_t[f(x&#39;)]$</span> via Gauss-Hermite quadrature (low dimension) or monomial rules (Judd, Maliar &amp; Maliar 2011)</li><li><strong>Initial guess</strong>: Warm-start from the first-order perturbation solution</li><li><strong>Newton iteration</strong>: Solve the nonlinear system of equilibrium residuals at all collocation nodes via Gauss-Newton with line search</li></ol><pre><code class="language-julia hljs">proj = collocation_solver(spec; degree=5, grid=:tensor)</code></pre><table><tr><th style="text-align: right">Keyword</th><th style="text-align: right">Type</th><th style="text-align: right">Default</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>degree</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right"><code>5</code></td><td style="text-align: right">Chebyshev polynomial degree</td></tr><tr><td style="text-align: right"><code>grid</code></td><td style="text-align: right"><code>Symbol</code></td><td style="text-align: right"><code>:auto</code></td><td style="text-align: right"><code>:tensor</code>, <code>:smolyak</code>, or <code>:auto</code></td></tr><tr><td style="text-align: right"><code>smolyak_mu</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right"><code>3</code></td><td style="text-align: right">Smolyak exactness level</td></tr><tr><td style="text-align: right"><code>quadrature</code></td><td style="text-align: right"><code>Symbol</code></td><td style="text-align: right"><code>:auto</code></td><td style="text-align: right"><code>:gauss_hermite</code>, <code>:monomial</code>, or <code>:auto</code></td></tr><tr><td style="text-align: right"><code>n_quad</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right"><code>5</code></td><td style="text-align: right">Quadrature nodes per shock dimension</td></tr><tr><td style="text-align: right"><code>scale</code></td><td style="text-align: right"><code>Real</code></td><td style="text-align: right"><code>3.0</code></td><td style="text-align: right">State bounds = SS <span>$\pm$</span> scale <span>$\times \sigma$</span></td></tr><tr><td style="text-align: right"><code>tol</code></td><td style="text-align: right"><code>Real</code></td><td style="text-align: right"><span>$10^{-8}$</span></td><td style="text-align: right">Newton convergence tolerance</td></tr><tr><td style="text-align: right"><code>max_iter</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right"><code>100</code></td><td style="text-align: right">Maximum Newton iterations</td></tr></table><h3 id="Smolyak-Sparse-Grids"><a class="docs-heading-anchor" href="#Smolyak-Sparse-Grids">Smolyak Sparse Grids</a><a id="Smolyak-Sparse-Grids-1"></a><a class="docs-heading-anchor-permalink" href="#Smolyak-Sparse-Grids" title="Permalink"></a></h3><p>For models with more than 3–4 state variables, tensor-product grids suffer from the curse of dimensionality: <span>$n^k$</span> grid points for <span>$k$</span> states with <span>$n$</span> nodes per dimension. Smolyak sparse grids (Judd, Maliar, Maliar &amp; Valero 2014) provide the same polynomial exactness with dramatically fewer points by selecting grid nodes via a combinatorial rule:</p><pre><code class="language-julia hljs">proj = collocation_solver(spec; grid=:smolyak, smolyak_mu=3)</code></pre><p>The <code>:auto</code> grid option selects tensor for <span>$n_x \leq 4$</span> and Smolyak otherwise.</p><h3 id="Evaluating-the-Policy-Function"><a class="docs-heading-anchor" href="#Evaluating-the-Policy-Function">Evaluating the Policy Function</a><a id="Evaluating-the-Policy-Function-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluating-the-Policy-Function" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Evaluate at a single state point (returns n_vars-vector of levels)
y = evaluate_policy(proj, x_state)

# Evaluate at multiple state points (n_points × nx → n_points × n_vars)
Y = evaluate_policy(proj, X_states)</code></pre><h3 id="Euler-Equation-Errors"><a class="docs-heading-anchor" href="#Euler-Equation-Errors">Euler Equation Errors</a><a id="Euler-Equation-Errors-1"></a><a class="docs-heading-anchor-permalink" href="#Euler-Equation-Errors" title="Permalink"></a></h3><p>The standard diagnostic for projection accuracy is the maximum Euler equation error on a fine test grid (Judd 1992):</p><pre><code class="language-julia hljs">err = max_euler_error(proj; n_test=1000)
println(&quot;Max Euler error: &quot;, err)</code></pre><p>Report <span>$\log_{10}(|\text{error}|)$</span>:</p><table><tr><th style="text-align: right"><span>$\log_{10}$</span> error</th><th style="text-align: right">Quality</th></tr><tr><td style="text-align: right"><span>$&lt; -5$</span></td><td style="text-align: right">Excellent</td></tr><tr><td style="text-align: right"><span>$-4$</span> to <span>$-5$</span></td><td style="text-align: right">Good</td></tr><tr><td style="text-align: right"><span>$-3$</span> to <span>$-4$</span></td><td style="text-align: right">Acceptable</td></tr><tr><td style="text-align: right"><span>$&gt; -3$</span></td><td style="text-align: right">Poor</td></tr></table><hr/><h2 id="Policy-Function-Iteration"><a class="docs-heading-anchor" href="#Policy-Function-Iteration">Policy Function Iteration</a><a id="Policy-Function-Iteration-1"></a><a class="docs-heading-anchor-permalink" href="#Policy-Function-Iteration" title="Permalink"></a></h2><p>Policy Function Iteration (PFI), also known as time iteration (Coleman 1990), is an alternative global solution method that iterates on the policy function directly rather than solving for collocation coefficients.</p><h3 id="Algorithm-3"><a class="docs-heading-anchor" href="#Algorithm-3">Algorithm</a><a class="docs-heading-anchor-permalink" href="#Algorithm-3" title="Permalink"></a></h3><p>At each iteration:</p><ol><li><strong>Evaluate current policy</strong> at all grid points</li><li><strong>Compute expected next-period values</strong> via quadrature: <span>$E[y&#39;] = \sum_q w_q \cdot g^{(k)}(x&#39;(x, \varepsilon_q))$</span></li><li><strong>Solve Euler equation</strong> at each grid point via Newton: given <span>$y_{\text{lag}}$</span> and <span>$E[y&#39;]$</span>, find <span>$y_t$</span> such that <span>$F(y_t, y_{\text{lag}}, E[y&#39;], 0, \theta) = 0$</span></li><li><strong>Refit Chebyshev coefficients</strong> via least squares on the updated policy values</li><li><strong>Check convergence</strong>: sup-norm of policy change</li></ol><p>PFI has the advantage of guaranteed contraction (under standard conditions) and natural handling of inequality constraints at the Newton step.</p><pre><code class="language-julia hljs">proj = pfi_solver(spec; degree=5, max_iter=500, damping=0.8)</code></pre><table><tr><th style="text-align: right">Keyword</th><th style="text-align: right">Type</th><th style="text-align: right">Default</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>degree</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right"><code>5</code></td><td style="text-align: right">Chebyshev polynomial degree</td></tr><tr><td style="text-align: right"><code>grid</code></td><td style="text-align: right"><code>Symbol</code></td><td style="text-align: right"><code>:auto</code></td><td style="text-align: right">Grid type (same as collocation)</td></tr><tr><td style="text-align: right"><code>max_iter</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right"><code>500</code></td><td style="text-align: right">Maximum PFI iterations</td></tr><tr><td style="text-align: right"><code>damping</code></td><td style="text-align: right"><code>Real</code></td><td style="text-align: right"><code>1.0</code></td><td style="text-align: right">Policy mixing factor (<span>$&lt;1$</span> for damped updates)</td></tr><tr><td style="text-align: right"><code>tol</code></td><td style="text-align: right"><code>Real</code></td><td style="text-align: right"><span>$10^{-8}$</span></td><td style="text-align: right">Sup-norm convergence tolerance</td></tr></table><h3 id="Return-Value-(Projection-and-PFI)"><a class="docs-heading-anchor" href="#Return-Value-(Projection-and-PFI)">Return Value (Projection and PFI)</a><a id="Return-Value-(Projection-and-PFI)-1"></a><a class="docs-heading-anchor-permalink" href="#Return-Value-(Projection-and-PFI)" title="Permalink"></a></h3><p>Both methods return a <code>ProjectionSolution{T}</code>:</p><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Type</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>coefficients</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right"><span>$n_{vars} \times n_{basis}$</span> Chebyshev coefficients</td></tr><tr><td style="text-align: right"><code>state_bounds</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right"><span>$n_x \times 2$</span> state domain bounds</td></tr><tr><td style="text-align: right"><code>grid_type</code></td><td style="text-align: right"><code>Symbol</code></td><td style="text-align: right"><code>:tensor</code> or <code>:smolyak</code></td></tr><tr><td style="text-align: right"><code>degree</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Polynomial degree or Smolyak level</td></tr><tr><td style="text-align: right"><code>residual_norm</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">Final residual norm</td></tr><tr><td style="text-align: right"><code>converged</code></td><td style="text-align: right"><code>Bool</code></td><td style="text-align: right">Convergence flag</td></tr><tr><td style="text-align: right"><code>iterations</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Iterations used</td></tr><tr><td style="text-align: right"><code>method</code></td><td style="text-align: right"><code>Symbol</code></td><td style="text-align: right"><code>:projection</code> or <code>:pfi</code></td></tr></table><hr/><h2 id="Simulation-and-IRFs"><a class="docs-heading-anchor" href="#Simulation-and-IRFs">Simulation and IRFs</a><a id="Simulation-and-IRFs-1"></a><a class="docs-heading-anchor-permalink" href="#Simulation-and-IRFs" title="Permalink"></a></h2><h3 id="Stochastic-Simulation"><a class="docs-heading-anchor" href="#Stochastic-Simulation">Stochastic Simulation</a><a id="Stochastic-Simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Stochastic-Simulation" title="Permalink"></a></h3><p><code>simulate</code> generates sample paths from the solved model. For <code>DSGESolution</code> (first-order):</p><p class="math-container">\[y_t = G_1 \, y_{t-1} + \text{impact} \cdot \varepsilon_t + C_{sol}\]</p><p>For <code>PerturbationSolution</code> (second-order), pruned simulation is used automatically (see <a href="#Pruning">Pruning</a>).</p><pre><code class="language-julia hljs">Y_sim = simulate(sol, 200; rng=Random.MersenneTwister(42))
# Returns 200 × n_endog matrix in levels (steady state + deviations)</code></pre><table><tr><th style="text-align: right">Keyword</th><th style="text-align: right">Type</th><th style="text-align: right">Default</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>shock_draws</code></td><td style="text-align: right"><code>Matrix</code></td><td style="text-align: right"><code>nothing</code></td><td style="text-align: right">Pre-drawn shocks (<span>$T \times n_{shocks}$</span>)</td></tr><tr><td style="text-align: right"><code>rng</code></td><td style="text-align: right"><code>AbstractRNG</code></td><td style="text-align: right"><code>default_rng()</code></td><td style="text-align: right">Random number generator</td></tr></table><h3 id="Impulse-Response-Functions"><a class="docs-heading-anchor" href="#Impulse-Response-Functions">Impulse Response Functions</a><a id="Impulse-Response-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Impulse-Response-Functions" title="Permalink"></a></h3><p><code>irf</code> computes analytical impulse responses. For first-order solutions:</p><p class="math-container">\[\Phi_h = G_1^{h-1} \cdot \text{impact}\]</p><p>where <span>$\Phi_h$</span> is the response at horizon <span>$h$</span> to a one-standard-deviation shock.</p><pre><code class="language-julia hljs">result = irf(sol, 40)
plot_result(result)</code></pre><p>Returns an <code>ImpulseResponse{T}</code> object compatible with <code>plot_result()</code> for multi-panel IRF plots.</p><h3 id="Generalized-IRFs-(Second-Order)"><a class="docs-heading-anchor" href="#Generalized-IRFs-(Second-Order)">Generalized IRFs (Second-Order)</a><a id="Generalized-IRFs-(Second-Order)-1"></a><a class="docs-heading-anchor-permalink" href="#Generalized-IRFs-(Second-Order)" title="Permalink"></a></h3><p>For second-order perturbation solutions, analytical IRFs capture only the first-order dynamics. Generalized IRFs (Koop, Pesaran &amp; Potter 1996) use Monte Carlo simulation to capture the nonlinear propagation:</p><p class="math-container">\[\text{GIRF}_h = E[y_{t+h} \mid \varepsilon_t = \delta] - E[y_{t+h} \mid \varepsilon_t = 0]\]</p><p>averaged over random draws of future shocks:</p><pre><code class="language-julia hljs">psol = perturbation_solver(spec; order=2)
girf = irf(psol, 40; irf_type=:girf, n_draws=500, shock_size=1.0)</code></pre><h3 id="Forecast-Error-Variance-Decomposition"><a class="docs-heading-anchor" href="#Forecast-Error-Variance-Decomposition">Forecast Error Variance Decomposition</a><a id="Forecast-Error-Variance-Decomposition-1"></a><a class="docs-heading-anchor-permalink" href="#Forecast-Error-Variance-Decomposition" title="Permalink"></a></h3><p><code>fevd</code> computes the share of forecast variance attributable to each shock at each horizon:</p><p class="math-container">\[\text{FEVD}_{ij}(h) = \frac{\sum_{s=0}^{h-1} (\Phi_s e_j)&#39; (\Phi_s e_j)}{\sum_{s=0}^{h-1} \text{tr}(\Phi_s \Phi_s&#39;)}\]</p><pre><code class="language-julia hljs">result = fevd(sol, 40)
plot_result(result)</code></pre><h3 id="Unconditional-Moments"><a class="docs-heading-anchor" href="#Unconditional-Moments">Unconditional Moments</a><a id="Unconditional-Moments-1"></a><a class="docs-heading-anchor-permalink" href="#Unconditional-Moments" title="Permalink"></a></h3><h4 id="Lyapunov-Equation"><a class="docs-heading-anchor" href="#Lyapunov-Equation">Lyapunov Equation</a><a id="Lyapunov-Equation-1"></a><a class="docs-heading-anchor-permalink" href="#Lyapunov-Equation" title="Permalink"></a></h4><p><code>solve_lyapunov</code> solves the discrete Lyapunov equation for the unconditional covariance:</p><p class="math-container">\[\Sigma = G_1 \, \Sigma \, G_1&#39; + \text{impact} \cdot \text{impact}&#39;\]</p><pre><code class="language-julia hljs">Sigma = solve_lyapunov(sol.G1, sol.impact)</code></pre><div class="admonition is-info" id="Technical-Note-49d5b09b372effcc"><header class="admonition-header">Technical Note<a class="admonition-anchor" href="#Technical-Note-49d5b09b372effcc" title="Permalink"></a></header><div class="admonition-body"><p>For first-order solutions, uses Kronecker vectorization: <span>$\text{vec}(\Sigma) = (I - G_1 \otimes G_1)^{-1} \text{vec}(\text{impact} \cdot \text{impact}&#39;)$</span>. For second-order perturbation solutions, the pruning module provides a doubling algorithm that is more numerically stable for large systems (<span>$O(n^3)$</span> per iteration vs <span>$O(n^6)$</span> for the Kronecker approach).</p></div></div><h4 id="Analytical-Moments-(First-Order)"><a class="docs-heading-anchor" href="#Analytical-Moments-(First-Order)">Analytical Moments (First-Order)</a><a id="Analytical-Moments-(First-Order)-1"></a><a class="docs-heading-anchor-permalink" href="#Analytical-Moments-(First-Order)" title="Permalink"></a></h4><p><code>analytical_moments</code> computes the theoretical moment vector from the Lyapunov solution:</p><pre><code class="language-julia hljs">m = analytical_moments(sol; lags=2)</code></pre><p>Returns a concatenated vector: upper-triangle of the variance-covariance matrix (<span>$k(k+1)/2$</span> elements) followed by diagonal autocovariances at each lag (<span>$k$</span> elements per lag). These moments are used internally by the <code>:analytical_gmm</code> estimation method.</p><h4 id="Analytical-Moments-(Second-Order)"><a class="docs-heading-anchor" href="#Analytical-Moments-(Second-Order)">Analytical Moments (Second-Order)</a><a id="Analytical-Moments-(Second-Order)-1"></a><a class="docs-heading-anchor-permalink" href="#Analytical-Moments-(Second-Order)" title="Permalink"></a></h4><p>For second-order perturbation solutions, closed-form moments are computed via the augmented-state Lyapunov approach (Andreasen, Fernandez-Villaverde &amp; Rubio-Ramirez 2018). The augmented state <span>$z = [x^{(1)}; x^{(2)}; \text{vec}(x^{(1)} \otimes x^{(1)})]$</span> of dimension <span>$2n_x + n_x^2$</span> satisfies a linear transition, enabling Lyapunov-based moment computation that captures the mean shift from the variance correction:</p><pre><code class="language-julia hljs">psol = perturbation_solver(spec; order=2)
m = analytical_moments(psol; lags=2, format=:gmm)</code></pre><p>The <code>:gmm</code> format returns means, product moments, and diagonal autocovariances –- suitable for GMM estimation with higher-order perturbation where unconditional means are non-zero.</p><hr/><h2 id="Estimation"><a class="docs-heading-anchor" href="#Estimation">Estimation</a><a id="Estimation-1"></a><a class="docs-heading-anchor-permalink" href="#Estimation" title="Permalink"></a></h2><p><code>estimate_dsge</code> estimates DSGE deep parameters via Generalized Method of Moments:</p><pre><code class="language-julia hljs">est = estimate_dsge(spec, Y_data, [:β, :ρ, :σ]; method=:irf_matching)
report(est)</code></pre><h3 id="Methods"><a class="docs-heading-anchor" href="#Methods">Methods</a><a id="Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Methods" title="Permalink"></a></h3><table><tr><th style="text-align: right">Method</th><th style="text-align: right">Description</th><th style="text-align: right">Reference</th></tr><tr><td style="text-align: right"><code>:irf_matching</code></td><td style="text-align: right">Match model IRFs to empirical VAR IRFs</td><td style="text-align: right">Christiano, Eichenbaum &amp; Evans (2005)</td></tr><tr><td style="text-align: right"><code>:euler_gmm</code></td><td style="text-align: right">Euler equation moment conditions with lagged instruments</td><td style="text-align: right">Hansen &amp; Singleton (1982)</td></tr><tr><td style="text-align: right"><code>:smm</code></td><td style="text-align: right">Simulated Method of Moments</td><td style="text-align: right">Lee &amp; Ingram (1991)</td></tr><tr><td style="text-align: right"><code>:analytical_gmm</code></td><td style="text-align: right">Analytical moments via Lyapunov equation</td><td style="text-align: right">–-</td></tr></table><h3 id="IRF-Matching"><a class="docs-heading-anchor" href="#IRF-Matching">IRF Matching</a><a id="IRF-Matching-1"></a><a class="docs-heading-anchor-permalink" href="#IRF-Matching" title="Permalink"></a></h3><p>Estimates parameters by minimizing the distance between model-implied and data-implied impulse responses:</p><p class="math-container">\[\hat{\theta} = \arg\min_\theta \, [\Phi^{data}(H) - \Phi^{model}(\theta, H)]&#39; \, W \, [\Phi^{data}(H) - \Phi^{model}(\theta, H)]\]</p><p>where <span>$\Phi^{data}$</span> is estimated from a VAR on the data and <span>$W$</span> is the GMM weighting matrix.</p><p><strong>When to use:</strong> When you have a VAR-identified structural shock and want to match the DSGE model&#39;s propagation mechanism to the data. This is the most common method for medium-scale DSGE models.</p><pre><code class="language-julia hljs">est = estimate_dsge(spec, Y_data, [:β, :α, :ρ];
                    method=:irf_matching,
                    var_lags=4,
                    irf_horizon=20,
                    weighting=:two_step)</code></pre><h3 id="Euler-Equation-GMM"><a class="docs-heading-anchor" href="#Euler-Equation-GMM">Euler Equation GMM</a><a id="Euler-Equation-GMM-1"></a><a class="docs-heading-anchor-permalink" href="#Euler-Equation-GMM" title="Permalink"></a></h3><p>Uses Euler equation residuals as moment conditions with lagged variables as instruments:</p><p class="math-container">\[E[f(y_t, y_{t-1}, y_{t+1}, 0, \theta) \otimes z_t] = 0\]</p><p>where <span>$z_t = [1, y_{t-1}, y_{t-2}, \ldots, y_{t-p}]$</span> are instruments.</p><p><strong>When to use:</strong> When the model has a well-defined Euler equation and you want to avoid the computational cost of repeatedly solving the model during optimization.</p><pre><code class="language-julia hljs">est = estimate_dsge(spec, Y_data, [:β, :ρ];
                    method=:euler_gmm,
                    n_lags_instruments=4)</code></pre><h3 id="Simulated-Method-of-Moments-(SMM)"><a class="docs-heading-anchor" href="#Simulated-Method-of-Moments-(SMM)">Simulated Method of Moments (SMM)</a><a id="Simulated-Method-of-Moments-(SMM)-1"></a><a class="docs-heading-anchor-permalink" href="#Simulated-Method-of-Moments-(SMM)" title="Permalink"></a></h3><p>Matches simulated moments to data moments:</p><p class="math-container">\[\hat{\theta} = \arg\min_\theta \, [m^{data} - m^{sim}(\theta)]&#39; \, W \, [m^{data} - m^{sim}(\theta)]\]</p><pre><code class="language-julia hljs">est = estimate_dsge(spec, Y_data, [:β, :ρ, :σ];
                    method=:smm,
                    sim_ratio=5,
                    burn=100)</code></pre><div class="admonition is-info" id="Simulation-noise-d3e0b483566f1c82"><header class="admonition-header">Simulation noise<a class="admonition-anchor" href="#Simulation-noise-d3e0b483566f1c82" title="Permalink"></a></header><div class="admonition-body"><p>SMM estimates are noisier than analytical GMM due to simulation error. Increase <code>sim_ratio</code> to reduce this noise. The asymptotic variance correction factor is <span>$(1 + 1/\text{sim\_ratio})$</span>.</p></div></div><h3 id="Analytical-GMM"><a class="docs-heading-anchor" href="#Analytical-GMM">Analytical GMM</a><a id="Analytical-GMM-1"></a><a class="docs-heading-anchor-permalink" href="#Analytical-GMM" title="Permalink"></a></h3><p>Uses Lyapunov-equation-based moments (no simulation noise):</p><p><strong>When to use:</strong> This is the most efficient method when the model is linear and you want to match second-moment properties. No simulation noise.</p><pre><code class="language-julia hljs">est = estimate_dsge(spec, Y_data, [:β, :ρ];
                    method=:analytical_gmm,
                    lags=2)</code></pre><h3 id="Hansen-J-test"><a class="docs-heading-anchor" href="#Hansen-J-test">Hansen J-test</a><a id="Hansen-J-test-1"></a><a class="docs-heading-anchor-permalink" href="#Hansen-J-test" title="Permalink"></a></h3><p>All methods report the overidentification test:</p><pre><code class="language-julia hljs">println(&quot;J-statistic: &quot;, est.J_stat)
println(&quot;p-value: &quot;, est.J_pvalue)</code></pre><p>A large p-value indicates the model&#39;s moment conditions are not rejected by the data.</p><h3 id="Keywords"><a class="docs-heading-anchor" href="#Keywords">Keywords</a><a id="Keywords-1"></a><a class="docs-heading-anchor-permalink" href="#Keywords" title="Permalink"></a></h3><table><tr><th style="text-align: right">Keyword</th><th style="text-align: right">Type</th><th style="text-align: right">Default</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>method</code></td><td style="text-align: right"><code>Symbol</code></td><td style="text-align: right"><code>:irf_matching</code></td><td style="text-align: right">Estimation method</td></tr><tr><td style="text-align: right"><code>target_irfs</code></td><td style="text-align: right"><code>ImpulseResponse</code></td><td style="text-align: right"><code>nothing</code></td><td style="text-align: right">Pre-computed empirical IRFs</td></tr><tr><td style="text-align: right"><code>var_lags</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right"><code>4</code></td><td style="text-align: right">VAR lag order for empirical IRFs</td></tr><tr><td style="text-align: right"><code>irf_horizon</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right"><code>20</code></td><td style="text-align: right">IRF horizon for matching</td></tr><tr><td style="text-align: right"><code>weighting</code></td><td style="text-align: right"><code>Symbol</code></td><td style="text-align: right"><code>:two_step</code></td><td style="text-align: right">GMM weighting matrix</td></tr><tr><td style="text-align: right"><code>n_lags_instruments</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right"><code>4</code></td><td style="text-align: right">Instrument lags for Euler GMM</td></tr><tr><td style="text-align: right"><code>sim_ratio</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right"><code>5</code></td><td style="text-align: right">Simulation ratio for SMM</td></tr><tr><td style="text-align: right"><code>burn</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right"><code>100</code></td><td style="text-align: right">Burn-in periods for SMM</td></tr><tr><td style="text-align: right"><code>moments_fn</code></td><td style="text-align: right"><code>Function</code></td><td style="text-align: right"><code>autocovariance_moments</code></td><td style="text-align: right">Moment function for SMM</td></tr><tr><td style="text-align: right"><code>bounds</code></td><td style="text-align: right"><code>ParameterTransform</code></td><td style="text-align: right"><code>nothing</code></td><td style="text-align: right">Parameter bounds</td></tr><tr><td style="text-align: right"><code>lags</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right"><code>1</code></td><td style="text-align: right">Autocovariance lags for analytical GMM</td></tr></table><h3 id="Return-Value-4"><a class="docs-heading-anchor" href="#Return-Value-4">Return Value</a><a class="docs-heading-anchor-permalink" href="#Return-Value-4" title="Permalink"></a></h3><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Type</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>theta</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">Estimated deep parameters</td></tr><tr><td style="text-align: right"><code>vcov</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right">Asymptotic covariance matrix</td></tr><tr><td style="text-align: right"><code>param_names</code></td><td style="text-align: right"><code>Vector{Symbol}</code></td><td style="text-align: right">Parameter names</td></tr><tr><td style="text-align: right"><code>method</code></td><td style="text-align: right"><code>Symbol</code></td><td style="text-align: right">Estimation method used</td></tr><tr><td style="text-align: right"><code>J_stat</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">Hansen J-test statistic</td></tr><tr><td style="text-align: right"><code>J_pvalue</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">J-test p-value</td></tr><tr><td style="text-align: right"><code>solution</code></td><td style="text-align: right"><code>DSGESolution{T}</code></td><td style="text-align: right">Solution at estimated parameters</td></tr><tr><td style="text-align: right"><code>converged</code></td><td style="text-align: right"><code>Bool</code></td><td style="text-align: right">Optimization convergence</td></tr><tr><td style="text-align: right"><code>spec</code></td><td style="text-align: right"><code>DSGESpec{T}</code></td><td style="text-align: right">Model specification</td></tr></table><p>Standard StatsAPI interface: <code>coef(est)</code>, <code>vcov(est)</code>, <code>stderror(est)</code>, <code>dof(est)</code>.</p><hr/><h2 id="Perfect-Foresight"><a class="docs-heading-anchor" href="#Perfect-Foresight">Perfect Foresight</a><a id="Perfect-Foresight-1"></a><a class="docs-heading-anchor-permalink" href="#Perfect-Foresight" title="Permalink"></a></h2><p><code>perfect_foresight</code> solves for the deterministic transition path given a known sequence of future shocks. Agents know the exact realization of shocks in advance (no uncertainty):</p><pre><code class="language-julia hljs">path = perfect_foresight(spec; T_periods=100, shock_path=shock_matrix)</code></pre><p>Or equivalently via <code>solve</code>:</p><pre><code class="language-julia hljs">sol = solve(spec; method=:perfect_foresight,
            T_periods=100, shock_path=shock_matrix)</code></pre><table><tr><th style="text-align: right">Keyword</th><th style="text-align: right">Type</th><th style="text-align: right">Default</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>T_periods</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right"><code>100</code></td><td style="text-align: right">Number of periods</td></tr><tr><td style="text-align: right"><code>shock_path</code></td><td style="text-align: right"><code>Matrix</code></td><td style="text-align: right">zeros</td><td style="text-align: right"><span>$T \times n_{shocks}$</span> shock sequence</td></tr><tr><td style="text-align: right"><code>max_iter</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right"><code>100</code></td><td style="text-align: right">Newton iteration limit</td></tr><tr><td style="text-align: right"><code>tol</code></td><td style="text-align: right"><code>Real</code></td><td style="text-align: right"><span>$10^{-8}$</span></td><td style="text-align: right">Convergence tolerance</td></tr></table><div class="admonition is-info" id="Technical-Note-a001671ef1467fa1"><header class="admonition-header">Technical Note<a class="admonition-anchor" href="#Technical-Note-a001671ef1467fa1" title="Permalink"></a></header><div class="admonition-body"><p>Uses a Newton solver with a sparse block-tridiagonal Jacobian. The system stacks all <span>$T$</span> periods into a single nonlinear system <span>$F(X) = 0$</span> where <span>$X = [y_1; y_2; \ldots; y_T]$</span> and iterates <span>$X^{(k+1)} = X^{(k)} - J^{-1} F(X^{(k)})$</span>. The Jacobian <span>$J$</span> has a block-tridiagonal sparsity pattern (each period <span>$t$</span> depends only on <span>$t-1, t, t+1$</span>) which is exploited for efficient factorization.</p></div></div><h3 id="Constrained-Perfect-Foresight-(JuMP/Ipopt)"><a class="docs-heading-anchor" href="#Constrained-Perfect-Foresight-(JuMP/Ipopt)">Constrained Perfect Foresight (JuMP/Ipopt)</a><a id="Constrained-Perfect-Foresight-(JuMP/Ipopt)-1"></a><a class="docs-heading-anchor-permalink" href="#Constrained-Perfect-Foresight-(JuMP/Ipopt)" title="Permalink"></a></h3><p>For deterministic paths subject to variable bounds:</p><pre><code class="language-julia hljs">import JuMP, Ipopt

bound = variable_bound(:R, lower=0.0)
path = perfect_foresight(spec, [bound]; T_periods=100, shock_path=shocks)</code></pre><h3 id="Constrained-Perfect-Foresight-(PATH-MCP)"><a class="docs-heading-anchor" href="#Constrained-Perfect-Foresight-(PATH-MCP)">Constrained Perfect Foresight (PATH MCP)</a><a id="Constrained-Perfect-Foresight-(PATH-MCP)-1"></a><a class="docs-heading-anchor-permalink" href="#Constrained-Perfect-Foresight-(PATH-MCP)" title="Permalink"></a></h3><p>The MCP formulation handles complementarity at each time period:</p><pre><code class="language-julia hljs">import JuMP, PATHSolver

bound = variable_bound(:R, lower=0.0)
path = perfect_foresight(spec, [bound]; T_periods=100, shock_path=shocks, solver=:path)</code></pre><h3 id="Constraint-Types"><a class="docs-heading-anchor" href="#Constraint-Types">Constraint Types</a><a id="Constraint-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Constraint-Types" title="Permalink"></a></h3><p>Two constraint types are available:</p><p><strong>Variable bounds</strong> restrict individual endogenous variables:</p><pre><code class="language-julia hljs">variable_bound(:R, lower=0.0)                     # ZLB: R_t &gt;= 0
variable_bound(:C, lower=0.0)                      # Non-negativity
variable_bound(:h, lower=0.0, upper=1.0)           # Hours in [0, 1]</code></pre><p><strong>Nonlinear constraints</strong> express general inequality conditions:</p><pre><code class="language-julia hljs"># Collateral constraint: debt &lt;= 0.8 * capital
nonlinear_constraint(
    (y, y_lag, y_lead, e, theta) -&gt; y[3] - 0.8 * y[1];
    label=&quot;collateral&quot;
)</code></pre><div class="admonition is-warning" id="Warning-f143f507b7593a07"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-f143f507b7593a07" title="Permalink"></a></header><div class="admonition-body"><p><code>NonlinearConstraint</code> is supported only with the Ipopt solver, not PATH. PATH requires that constraints reduce to box bounds (variable bounds).</p></div></div><h3 id="Return-Value-5"><a class="docs-heading-anchor" href="#Return-Value-5">Return Value</a><a class="docs-heading-anchor-permalink" href="#Return-Value-5" title="Permalink"></a></h3><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Type</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>path</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right"><span>$T \times n_{endog}$</span> level values</td></tr><tr><td style="text-align: right"><code>deviations</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right"><span>$T \times n_{endog}$</span> deviations from SS</td></tr><tr><td style="text-align: right"><code>converged</code></td><td style="text-align: right"><code>Bool</code></td><td style="text-align: right">Newton convergence flag</td></tr><tr><td style="text-align: right"><code>iterations</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Newton iterations used</td></tr><tr><td style="text-align: right"><code>spec</code></td><td style="text-align: right"><code>DSGESpec{T}</code></td><td style="text-align: right">Model specification</td></tr></table><hr/><h2 id="Occasionally-Binding-Constraints-(OccBin)"><a class="docs-heading-anchor" href="#Occasionally-Binding-Constraints-(OccBin)">Occasionally Binding Constraints (OccBin)</a><a id="Occasionally-Binding-Constraints-(OccBin)-1"></a><a class="docs-heading-anchor-permalink" href="#Occasionally-Binding-Constraints-(OccBin)" title="Permalink"></a></h2><p>The OccBin method (Guerrieri &amp; Iacoviello 2015) solves DSGE models with occasionally binding constraints using a piecewise-linear approximation. The economy switches between a <strong>reference regime</strong> (constraint slack) and an <strong>alternative regime</strong> (constraint binding), and the solution iterates until the regime sequence is self-consistent.</p><h3 id="Parsing-Constraints"><a class="docs-heading-anchor" href="#Parsing-Constraints">Parsing Constraints</a><a id="Parsing-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Parsing-Constraints" title="Permalink"></a></h3><pre><code class="language-julia hljs">constraint = parse_constraint(:(R[t] &gt;= 0), spec)</code></pre><p>Supports <code>&gt;=</code> and <code>&lt;=</code> directions. The variable must exist in <code>spec.endog</code>.</p><h3 id="One-Constraint"><a class="docs-heading-anchor" href="#One-Constraint">One Constraint</a><a id="One-Constraint-1"></a><a class="docs-heading-anchor-permalink" href="#One-Constraint" title="Permalink"></a></h3><p>The typical use case is a zero lower bound on the nominal interest rate:</p><pre><code class="language-julia hljs"># Large negative demand shock pushes economy to ZLB
shocks = zeros(60, 1)
shocks[1, 1] = -8.0

occ_sol = occbin_solve(spec, constraint; shock_path=shocks)

# Inspect convergence
println(&quot;Converged: &quot;, occ_sol.converged)
println(&quot;Iterations: &quot;, occ_sol.iterations)

# Regime history: 0 = slack, 1 = binding
println(&quot;Binding periods: &quot;, findall(vec(occ_sol.regime_history[:, 1]) .== 1))</code></pre><table><tr><th style="text-align: right">Keyword</th><th style="text-align: right">Type</th><th style="text-align: right">Default</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>shock_path</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right">zeros</td><td style="text-align: right"><span>$T \times n_{shocks}$</span> shock sequence</td></tr><tr><td style="text-align: right"><code>nperiods</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right"><code>size(shock_path, 1)</code></td><td style="text-align: right">Number of periods</td></tr><tr><td style="text-align: right"><code>maxiter</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right"><code>100</code></td><td style="text-align: right">Max guess-and-verify iterations</td></tr></table><div class="admonition is-info" id="Guess-and-Verify-Algorithm-8ddcdbea2c127aa5"><header class="admonition-header">Guess-and-Verify Algorithm<a class="admonition-anchor" href="#Guess-and-Verify-Algorithm-8ddcdbea2c127aa5" title="Permalink"></a></header><div class="admonition-body"><ol><li>Solve the unconstrained (reference) model and the alternative (binding) model separately</li><li>Guess an initial regime sequence (all slack)</li><li>Compute time-varying decision rules via backward iteration from the terminal period</li><li>Simulate forward using the time-varying rules</li><li>Check whether the constraint is satisfied at each period –- update the regime guess</li><li>Repeat until the regime sequence converges</li></ol></div></div><h3 id="Two-Constraints"><a class="docs-heading-anchor" href="#Two-Constraints">Two Constraints</a><a id="Two-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Two-Constraints" title="Permalink"></a></h3><p>For models with two occasionally binding constraints (4 possible regime combinations):</p><pre><code class="language-julia hljs">c1 = parse_constraint(:(R[t] &gt;= 0), spec)       # ZLB
c2 = parse_constraint(:(debt[t] &lt;= limit), spec) # Debt ceiling

occ_sol = occbin_solve(spec, c1, c2; shock_path=shocks)</code></pre><p>The four regimes are: (0,0) neither binds, (1,0) only first binds, (0,1) only second binds, (1,1) both bind.</p><h3 id="OccBin-IRFs"><a class="docs-heading-anchor" href="#OccBin-IRFs">OccBin IRFs</a><a id="OccBin-IRFs-1"></a><a class="docs-heading-anchor-permalink" href="#OccBin-IRFs" title="Permalink"></a></h3><p>Compare linear (unconstrained) and piecewise-linear (constrained) impulse responses:</p><pre><code class="language-julia hljs">occ_irf = occbin_irf(spec, constraint, 1, 40; magnitude=3.0)
plot_result(occ_irf)</code></pre><p>The plot shows how the ZLB amplifies the output decline: the constrained path (red) drops further than the linear path (blue) because the interest rate cannot go below zero to stimulate the economy.</p><table><tr><th style="text-align: right">Keyword</th><th style="text-align: right">Type</th><th style="text-align: right">Default</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>magnitude</code></td><td style="text-align: right"><code>Real</code></td><td style="text-align: right"><code>1.0</code></td><td style="text-align: right">Shock size (standard deviations)</td></tr><tr><td style="text-align: right"><code>maxiter</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right"><code>100</code></td><td style="text-align: right">Max guess-and-verify iterations</td></tr></table><h3 id="Return-Values"><a class="docs-heading-anchor" href="#Return-Values">Return Values</a><a id="Return-Values-1"></a><a class="docs-heading-anchor-permalink" href="#Return-Values" title="Permalink"></a></h3><p><strong><code>OccBinSolution{T}</code>:</strong></p><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Type</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>linear_path</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right"><span>$T \times n$</span> unconstrained path</td></tr><tr><td style="text-align: right"><code>piecewise_path</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right"><span>$T \times n$</span> constrained path</td></tr><tr><td style="text-align: right"><code>steady_state</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">Steady-state values</td></tr><tr><td style="text-align: right"><code>regime_history</code></td><td style="text-align: right"><code>Matrix{Int}</code></td><td style="text-align: right"><span>$T \times n_c$</span> regime indicators (0=slack, 1=binding)</td></tr><tr><td style="text-align: right"><code>converged</code></td><td style="text-align: right"><code>Bool</code></td><td style="text-align: right">Convergence flag</td></tr><tr><td style="text-align: right"><code>iterations</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Guess-and-verify iterations</td></tr></table><p><strong><code>OccBinIRF{T}</code>:</strong></p><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Type</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>linear</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right"><span>$H \times n$</span> linear IRF</td></tr><tr><td style="text-align: right"><code>piecewise</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right"><span>$H \times n$</span> piecewise IRF</td></tr><tr><td style="text-align: right"><code>regime_history</code></td><td style="text-align: right"><code>Matrix{Int}</code></td><td style="text-align: right"><span>$H \times n_c$</span> regime indicators</td></tr><tr><td style="text-align: right"><code>shock_name</code></td><td style="text-align: right"><code>String</code></td><td style="text-align: right">Name of shocked variable</td></tr></table><hr/><h2 id="Complete-Example"><a class="docs-heading-anchor" href="#Complete-Example">Complete Example</a><a id="Complete-Example-1"></a><a class="docs-heading-anchor-permalink" href="#Complete-Example" title="Permalink"></a></h2><p>A 3-equation New Keynesian model with an IS curve, Phillips curve, and Taylor rule –- solved with multiple methods, estimated, and subjected to a ZLB constraint.</p><pre><code class="language-julia hljs">using MacroEconometricModels, Random
Random.seed!(42)

# ── 1. Model specification ──
spec = @dsge begin
    parameters: β = 0.99, σ_c = 1.0, κ = 0.3, φ_π = 1.5, φ_y = 0.5,
                ρ_d = 0.8, ρ_s = 0.7, σ_d = 0.01, σ_s = 0.01
    endogenous: y, π, R, d, s
    exogenous: ε_d, ε_s

    # IS curve (forward-looking demand)
    y[t] = y[t+1] - (1 / σ_c) * (R[t] - π[t+1]) + d[t]

    # New Keynesian Phillips curve (Calvo pricing)
    π[t] = β * π[t+1] + κ * y[t] + s[t]

    # Taylor rule (monetary policy)
    R[t] = φ_π * π[t] + φ_y * y[t]

    # Demand shock (AR(1))
    d[t] = ρ_d * d[t-1] + σ_d * ε_d[t]

    # Supply shock (AR(1))
    s[t] = ρ_s * s[t-1] + σ_s * ε_s[t]
end

# ── 2. First-order solution ──
sol = solve(spec)
println(&quot;Determined: &quot;, is_determined(sol))
println(&quot;Stable: &quot;, is_stable(sol))

# ── 3. Impulse responses and FEVD ──
irf_result = irf(sol, 40)
plot_result(irf_result)

fevd_result = fevd(sol, 40)
plot_result(fevd_result)

# ── 4. Simulation and analytical moments ──
Y_sim = simulate(sol, 200; rng=Random.MersenneTwister(42))
Sigma = solve_lyapunov(sol.G1, sol.impact)
m = analytical_moments(sol; lags=2)
println(&quot;Unconditional variance of output: &quot;, Sigma[1, 1])

# ── 5. Second-order perturbation ──
psol = perturbation_solver(spec; order=2)
Y_sim_2nd = simulate(psol, 1000)  # pruned
girf = irf(psol, 40; irf_type=:girf, n_draws=200)

# ── 6. Estimation (IRF matching) ──
# est = estimate_dsge(spec, Y_data, [:κ, :φ_π, :ρ_d];
#                     method=:irf_matching, var_lags=4, irf_horizon=20)
# report(est)

# ── 7. OccBin: Zero lower bound ──
constraint = parse_constraint(:(R[t] &gt;= 0), spec)

shocks = zeros(40, 2)
shocks[1, 1] = -3.0  # Large negative demand shock

occ_sol = occbin_solve(spec, constraint; shock_path=shocks)
println(occ_sol)

occ_irf = occbin_irf(spec, constraint, 1, 40; magnitude=3.0)
plot_result(occ_irf)</code></pre><hr/><h2 id="Common-Pitfalls"><a class="docs-heading-anchor" href="#Common-Pitfalls">Common Pitfalls</a><a id="Common-Pitfalls-1"></a><a class="docs-heading-anchor-permalink" href="#Common-Pitfalls" title="Permalink"></a></h2><h3 id="Wrong-Steady-State"><a class="docs-heading-anchor" href="#Wrong-Steady-State">Wrong Steady State</a><a id="Wrong-Steady-State-1"></a><a class="docs-heading-anchor-permalink" href="#Wrong-Steady-State" title="Permalink"></a></h3><p>If the numerical solver converges to the wrong steady state, the linearization will be incorrect. Prefer analytical steady states via the <code>steady_state = begin ... end</code> block when possible.</p><pre><code class="language-julia hljs">spec = compute_steady_state(spec)
println(&quot;Steady state: &quot;, spec.steady_state)</code></pre><h3 id="Indeterminate-Model"><a class="docs-heading-anchor" href="#Indeterminate-Model">Indeterminate Model</a><a id="Indeterminate-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Indeterminate-Model" title="Permalink"></a></h3><p>If <code>is_determined(sol)</code> returns <code>false</code>, the model has sunspot equilibria. Common fix: ensure the Taylor principle holds (<span>$\phi_\pi &gt; 1$</span>).</p><h3 id="Explosive-Higher-Order-Simulations"><a class="docs-heading-anchor" href="#Explosive-Higher-Order-Simulations">Explosive Higher-Order Simulations</a><a id="Explosive-Higher-Order-Simulations-1"></a><a class="docs-heading-anchor-permalink" href="#Explosive-Higher-Order-Simulations" title="Permalink"></a></h3><p>If second-order simulations diverge, ensure you are using <code>PerturbationSolution</code> (which applies pruning automatically) rather than naively simulating the quadratic decision rules.</p><h3 id="Non-Convergence-in-Estimation"><a class="docs-heading-anchor" href="#Non-Convergence-in-Estimation">Non-Convergence in Estimation</a><a id="Non-Convergence-in-Estimation-1"></a><a class="docs-heading-anchor-permalink" href="#Non-Convergence-in-Estimation" title="Permalink"></a></h3><p>If <code>estimate_dsge</code> doesn&#39;t converge:</p><ul><li><strong>Narrow the parameter space</strong> with <code>bounds</code> via <code>ParameterTransform</code></li><li><strong>Try different starting values</strong> –- the optimizer may be stuck in a local minimum</li><li><strong>Check identification</strong> –- some parameters may not be identified from your chosen moments</li><li><strong>Increase horizon</strong> –- for IRF matching, a longer <code>irf_horizon</code> may help</li></ul><h3 id="Equation-Count-Mismatch"><a class="docs-heading-anchor" href="#Equation-Count-Mismatch">Equation Count Mismatch</a><a id="Equation-Count-Mismatch-1"></a><a class="docs-heading-anchor-permalink" href="#Equation-Count-Mismatch" title="Permalink"></a></h3><p>The <code>@dsge</code> macro requires exactly one equation per endogenous variable. If you need an interest rate smoothing rule, combine the Taylor rule and smoothing into one equation rather than writing two equations for <code>R</code>.</p><h3 id="Projection-Accuracy"><a class="docs-heading-anchor" href="#Projection-Accuracy">Projection Accuracy</a><a id="Projection-Accuracy-1"></a><a class="docs-heading-anchor-permalink" href="#Projection-Accuracy" title="Permalink"></a></h3><p>If <code>max_euler_error</code> returns values above <span>$10^{-3}$</span>:</p><ul><li><strong>Increase polynomial degree</strong> (try <code>degree=7</code> or <code>degree=9</code>)</li><li><strong>Widen state bounds</strong> (<code>scale=4.0</code> or <code>scale=5.0</code>)</li><li><strong>Use more quadrature nodes</strong> (<code>n_quad=7</code>)</li><li><strong>Check that the model is well-conditioned</strong> –- degenerate near-zero steady-state values can cause numerical issues</li></ul><hr/><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><ul><li>Andreasen, M. M., Fernandez-Villaverde, J., &amp; Rubio-Ramirez, J. F. (2018). The Pruned State-Space System for Non-Linear DSGE Models: Theory and Empirical Applications. <em>Review of Economic Studies</em>, 85(1), 1–49. <a href="https://doi.org/10.1093/restud/rdx037">DOI</a></li><li>Blanchard, O. J., &amp; Kahn, C. M. (1980). The Solution of Linear Difference Models under Rational Expectations. <em>Econometrica</em>, 48(5), 1305–1311. <a href="https://doi.org/10.2307/1912186">DOI</a></li><li>Christiano, L. J., Eichenbaum, M., &amp; Evans, C. L. (2005). Nominal Rigidities and the Dynamic Effects of a Shock to Monetary Policy. <em>Journal of Political Economy</em>, 113(1), 1–45. <a href="https://doi.org/10.1086/426038">DOI</a></li><li>Coleman, W. J. (1990). Solving the Stochastic Growth Model by Policy-Function Iteration. <em>Journal of Business &amp; Economic Statistics</em>, 8(1), 27–29. <a href="https://doi.org/10.1080/07350015.1990.10509769">DOI</a></li><li>Guerrieri, L., &amp; Iacoviello, M. (2015). OccBin: A Toolkit for Solving Dynamic Models with Occasionally Binding Constraints Easily. <em>Journal of Monetary Economics</em>, 70, 22–38. <a href="https://doi.org/10.1016/j.jmoneco.2014.08.005">DOI</a></li><li>Hansen, L. P. (1982). Large Sample Properties of Generalized Method of Moments Estimators. <em>Econometrica</em>, 50(4), 1029–1054. <a href="https://doi.org/10.2307/1912775">DOI</a></li><li>Hansen, L. P., &amp; Singleton, K. J. (1982). Generalized Instrumental Variables Estimation of Nonlinear Rational Expectations Models. <em>Econometrica</em>, 50(5), 1269–1286. <a href="https://doi.org/10.2307/1911873">DOI</a></li><li>Judd, K. L. (1992). Projection Methods for Solving Aggregate Growth Models. <em>Journal of Economic Theory</em>, 58(2), 410–452. <a href="https://doi.org/10.1016/0022-0531(92)90061-L">DOI</a></li><li>Judd, K. L. (1998). <em>Numerical Methods in Economics</em>. Cambridge, MA: MIT Press. ISBN: 0-262-10071-1.</li><li>Judd, K. L., Maliar, L., Maliar, S., &amp; Valero, R. (2014). Smolyak Method for Solving Dynamic Economic Models. <em>Journal of Economic Dynamics and Control</em>, 44, 92–123. <a href="https://doi.org/10.1016/j.jedc.2014.03.003">DOI</a></li><li>Kim, J., Kim, S., Schaumburg, E., &amp; Sims, C. A. (2008). Calculating and Using Second-Order Accurate Solutions of Discrete Time Dynamic Equilibrium Models. <em>Journal of Economic Dynamics and Control</em>, 32(11), 3397–3414. <a href="https://doi.org/10.1016/j.jedc.2008.02.003">DOI</a></li><li>Klein, P. (2000). Using the Generalized Schur Form to Solve a Multivariate Linear Rational Expectations Model. <em>Journal of Economic Dynamics and Control</em>, 24(10), 1405–1423. <a href="https://doi.org/10.1016/S0165-1889(99)00045-7">DOI</a></li><li>Koop, G., Pesaran, M. H., &amp; Potter, S. M. (1996). Impulse Response Analysis in Nonlinear Multivariate Models. <em>Journal of Econometrics</em>, 74(1), 119–147. <a href="https://doi.org/10.1016/0304-4076(95)01753-4">DOI</a></li><li>Lee, B. S., &amp; Ingram, B. F. (1991). Simulation Estimation of Time-Series Models. <em>Journal of Econometrics</em>, 47(2–3), 197–205. <a href="https://doi.org/10.1016/0304-4076(91)90098-X">DOI</a></li><li>Schmitt-Grohe, S., &amp; Uribe, M. (2004). Solving Dynamic General Equilibrium Models Using a Second-Order Approximation to the Policy Function. <em>Journal of Economic Dynamics and Control</em>, 28(4), 755–775. <a href="https://doi.org/10.1016/S0165-1889(03)00043-5">DOI</a></li><li>Sims, C. A. (2002). Solving Linear Rational Expectations Models. <em>Computational Economics</em>, 20(1–2), 1–20. <a href="https://doi.org/10.1023/A:1020517101123">DOI</a></li><li>Smets, F., &amp; Wouters, R. (2007). Shocks and Frictions in US Business Cycles: A Bayesian DSGE Approach. <em>American Economic Review</em>, 97(3), 586–606. <a href="https://doi.org/10.1257/aer.97.3.586">DOI</a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../pvar/">« Panel VAR</a><a class="docs-footer-nextpage" href="../innovation_accounting/">Innovation Accounting »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.17.0 on <span class="colophon-date" title="Wednesday 25 February 2026 02:01">Wednesday 25 February 2026</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
